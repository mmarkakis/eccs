{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ECCS: Exposing Critical Causal Structures","text":"<p>Welcome to the repository for the ECCS project! You can access the documentation here.</p> <p>For technical details about the project, you can read our paper. </p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li> <p>Setting up a virtual environment and installing dependencies.</p> </li> <li> <p>Reproducing our evaluation</p> </li> <li> <p>Rebuilding the documentation</p> </li> </ol>"},{"location":"#1-setting-up-a-virtual-environment-and-installing-dependencies","title":"1. Setting up a virtual environment and installing dependencies","text":"<p>Using a virtual environment is recommended to ensure dependencies are managed correctly. This section will walk you through setting up a virtual environment for this project. Before starting, make sure you have:</p> <ul> <li>Python 3 installed on your system</li> <li>Access to the command line/terminal</li> </ul>"},{"location":"#11-creating-the-virtual-environment","title":"1.1. Creating the Virtual Environment","text":"<p>First, navigate to the project's root directory in your terminal. Then, create a virtual environment by running:</p> <pre><code>python3 -m venv eccs-venv\n</code></pre> <p>This command creates a new directory <code>eccs-venv</code> in your project where the virtual environment files are stored.</p>"},{"location":"#12-activating-the-virtual-environment","title":"1.2. Activating the Virtual Environment","text":"<p>To activate the virtual environment, use the following command:</p> <p>On Windows: <pre><code>.\\eccs-venv\\Scripts\\activate\n</code></pre></p> <p>On macOS and Linux: <pre><code>source eccs-venv/bin/activate\n</code></pre></p> <p>After activation, your terminal prompt will change to indicate that the virtual environment is active.</p>"},{"location":"#13-installing-dependencies","title":"1.3. Installing Dependencies","text":"<p>With the virtual environment active, install the project dependencies by running:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"#14-deactivating-the-virtual-environment","title":"1.4. Deactivating the Virtual Environment","text":"<p>When you're done working in the virtual environment, you can deactivate it by running:</p> <pre><code>deactivate\n</code></pre> <p>This command will return you to your system's default Python interpreter.</p>"},{"location":"#2-reproducing-our-evaluation","title":"2. Reproducing our evaluation","text":"<p>Reproducing our evaluation is super easy! Just run the following command from the root of this repository (within the virtual environment you created above):</p> <pre><code>python3 src/evaluation/iterative_runner.py\n</code></pre> <p>An experimental directory will be created under <code>evaluation/</code>, named after the current timestamp <code>&lt;ts&gt;</code>. After the experimental run completes, you will be able to find plots like the ones included in Figure 2 of our paper under <code>evaluation/&lt;ts&gt;/plots/</code>. Note that each experimental run creates new ground truth causal graphs, datasets, and starting causal graphs, so your plots may vary from the results in the paper.</p> <p>You can edit <code>src/evaluation/iterative_config.yml</code> to adjust any experimental parameters.</p> <p>NOTE: Running all of the experiments in our evaluation can take several hours, depending on your hardware. You may want to use a tool like tmux to run the above command in the background.</p>"},{"location":"#3-rebuilding-the-documentation","title":"3. Rebuilding the documentation","text":"<p>To rebuild the documentation after editing the code, you can run:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>eccs<ul> <li>ate</li> <li>eccs</li> <li>edge_state_matrix</li> <li>edges</li> <li>graph_renderer</li> <li>heuristic_search</li> <li>map_adj_set_to_graph</li> </ul> </li> <li>evaluation<ul> <li>heuristic_test_runner</li> <li>iterative_runner</li> <li>plotter</li> <li>simple_runner</li> <li>user</li> </ul> </li> <li>generators<ul> <li>random_dag_generator</li> <li>random_dataset_generator</li> </ul> </li> </ul>"},{"location":"reference/eccs/","title":"Index","text":""},{"location":"reference/eccs/ate/","title":"ATE","text":""},{"location":"reference/eccs/ate/#eccs.ate.ATECalculator","title":"<code>ATECalculator</code>","text":"<p>A class to calculate ATEs.</p> Source code in <code>src/eccs/ate.py</code> <pre><code>class ATECalculator:\n    \"\"\"\n    A class to calculate ATEs.\n    \"\"\"\n\n    ATE_cache = {}\n\n    def _get_backdoor_estimand_expr(self, estimand):\n        # estimand is IdentifiedEstimand\n        for k, v in estimand.items():\n            if k != \"backdoor\":\n                continue\n            sp_expr_str = sp.pretty(v[\"estimand\"], use_unicode=True)\n            return sp_expr_str\n        return None\n\n    def get_ate_and_confidence(\n        self,\n        data: pd.DataFrame,\n        treatment: str | int,\n        outcome: str | int,\n        graph: Optional[nx.DiGraph] = None,\n        calculate_p_value: bool = False,\n        calculate_std_error: bool = False,\n        get_estimand: bool = False,\n        print_timing_info: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Calculate the ATE of `treatment` on `outcome`, alongside confidence measures.\n\n        Parameters:\n            data: The data to be used for causal analysis.\n            treatment: The name or index of the treatment variable.\n            outcome: The name or index of the outcome variable.\n            graph: The graph to be used for causal analysis. If not specified, a two-node graph with just\n                `treatment` and `outcome` is used.\n            calculate_p_value: Whether to calculate the P-value of the ATE.\n            calculate_std_error: Whether to calculate the standard error of the ATE.\n            get_estimand: Whether to return the estimand used to calculate the ATE, as part of the returned dictionary.\n            print_timing_info: Whether to print timing information.\n\n        Returns:\n            A dictionary containing the ATE of `treatment` on `outcome`, alongside confidence measures. If\n            `get_estimand` is True, the estimand used to calculate the ATE is also returned.\n        \"\"\"\n        timings = []\n        timings.append(datetime.now())\n\n        treatment_name = (\n            data.columns[treatment] if isinstance(treatment, int) else treatment\n        )\n        outcome_name = data.columns[outcome] if isinstance(outcome, int) else outcome\n\n        if graph is None:\n            graph = nx.DiGraph()\n            graph.add_node(treatment_name)\n            graph.add_node(outcome_name)\n            graph.add_edge(treatment_name, outcome_name)\n\n        # Use dowhy to get the ATE, P-value and standard error.\n        timings.append(datetime.now())\n        d = {}\n\n        with open(\"/dev/null\", \"w+\") as f:\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n\n                try:\n                    with contextlib.redirect_stdout(f), contextlib.redirect_stderr(f):\n                        timings.append(datetime.now())\n                        model = CausalModel(\n                            data=data[list(graph.nodes)],\n                            treatment=treatment_name,\n                            outcome=outcome_name,\n                            graph=graph,\n                        )\n                        timings.append(datetime.now())\n                        identified_estimand = model.identify_effect(\n                            proceed_when_unidentifiable=True\n                        )\n                        estimand_identifier = None\n                        try:\n                            estimand_identifier = self._get_backdoor_estimand_expr(\n                                identified_estimand\n                            )\n                        except:\n                            estimand_identifier = None\n                        if (\n                            estimand_identifier is not None\n                            and estimand_identifier in self.ATE_cache\n                        ):\n                            return self.ATE_cache[estimand_identifier]\n\n                        timings.append(datetime.now())\n                        estimate = model.estimate_effect(\n                            identified_estimand,\n                            method_name=\"backdoor.linear_regression\",\n                            test_significance=True,\n                        )\n                        timings.append(datetime.now())\n                        p_value = (\n                            estimate.test_stat_significance()[\"p_value\"].astype(float)[\n                                0\n                            ]\n                            if calculate_p_value\n                            else None\n                        )\n                        timings.append(datetime.now())\n                        stderr = (\n                            estimate.get_standard_error()\n                            if calculate_std_error\n                            else None\n                        )\n                        timings.append(datetime.now())\n                        d = {\n                            \"ATE\": float(estimate.value),\n                            \"P-value\": p_value,\n                            \"Standard Error\": stderr,\n                        }\n                        if get_estimand:\n                            d[\"Estimand\"] = identified_estimand\n                        if estimand_identifier is not None:\n                            self.ATE_cache[estimand_identifier] = d\n\n                except:\n                    raise ValueError\n\n        timings.append(datetime.now())\n        if print_timing_info:\n            print(\"\\tTimings:\")\n            for i in range(1, len(timings)):\n                print(f\"\\t\\tStep {i}: {timings[i] - timings[i-1]}\")\n\n        return d\n</code></pre>"},{"location":"reference/eccs/ate/#eccs.ate.ATECalculator.get_ate_and_confidence","title":"<code>get_ate_and_confidence(data, treatment, outcome, graph=None, calculate_p_value=False, calculate_std_error=False, get_estimand=False, print_timing_info=False)</code>","text":"<p>Calculate the ATE of <code>treatment</code> on <code>outcome</code>, alongside confidence measures.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The data to be used for causal analysis.</p> required <code>treatment</code> <code>str | int</code> <p>The name or index of the treatment variable.</p> required <code>outcome</code> <code>str | int</code> <p>The name or index of the outcome variable.</p> required <code>graph</code> <code>Optional[DiGraph]</code> <p>The graph to be used for causal analysis. If not specified, a two-node graph with just <code>treatment</code> and <code>outcome</code> is used.</p> <code>None</code> <code>calculate_p_value</code> <code>bool</code> <p>Whether to calculate the P-value of the ATE.</p> <code>False</code> <code>calculate_std_error</code> <code>bool</code> <p>Whether to calculate the standard error of the ATE.</p> <code>False</code> <code>get_estimand</code> <code>bool</code> <p>Whether to return the estimand used to calculate the ATE, as part of the returned dictionary.</p> <code>False</code> <code>print_timing_info</code> <code>bool</code> <p>Whether to print timing information.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the ATE of <code>treatment</code> on <code>outcome</code>, alongside confidence measures. If</p> <code>dict[str, Any]</code> <p><code>get_estimand</code> is True, the estimand used to calculate the ATE is also returned.</p> Source code in <code>src/eccs/ate.py</code> <pre><code>def get_ate_and_confidence(\n    self,\n    data: pd.DataFrame,\n    treatment: str | int,\n    outcome: str | int,\n    graph: Optional[nx.DiGraph] = None,\n    calculate_p_value: bool = False,\n    calculate_std_error: bool = False,\n    get_estimand: bool = False,\n    print_timing_info: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Calculate the ATE of `treatment` on `outcome`, alongside confidence measures.\n\n    Parameters:\n        data: The data to be used for causal analysis.\n        treatment: The name or index of the treatment variable.\n        outcome: The name or index of the outcome variable.\n        graph: The graph to be used for causal analysis. If not specified, a two-node graph with just\n            `treatment` and `outcome` is used.\n        calculate_p_value: Whether to calculate the P-value of the ATE.\n        calculate_std_error: Whether to calculate the standard error of the ATE.\n        get_estimand: Whether to return the estimand used to calculate the ATE, as part of the returned dictionary.\n        print_timing_info: Whether to print timing information.\n\n    Returns:\n        A dictionary containing the ATE of `treatment` on `outcome`, alongside confidence measures. If\n        `get_estimand` is True, the estimand used to calculate the ATE is also returned.\n    \"\"\"\n    timings = []\n    timings.append(datetime.now())\n\n    treatment_name = (\n        data.columns[treatment] if isinstance(treatment, int) else treatment\n    )\n    outcome_name = data.columns[outcome] if isinstance(outcome, int) else outcome\n\n    if graph is None:\n        graph = nx.DiGraph()\n        graph.add_node(treatment_name)\n        graph.add_node(outcome_name)\n        graph.add_edge(treatment_name, outcome_name)\n\n    # Use dowhy to get the ATE, P-value and standard error.\n    timings.append(datetime.now())\n    d = {}\n\n    with open(\"/dev/null\", \"w+\") as f:\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n\n            try:\n                with contextlib.redirect_stdout(f), contextlib.redirect_stderr(f):\n                    timings.append(datetime.now())\n                    model = CausalModel(\n                        data=data[list(graph.nodes)],\n                        treatment=treatment_name,\n                        outcome=outcome_name,\n                        graph=graph,\n                    )\n                    timings.append(datetime.now())\n                    identified_estimand = model.identify_effect(\n                        proceed_when_unidentifiable=True\n                    )\n                    estimand_identifier = None\n                    try:\n                        estimand_identifier = self._get_backdoor_estimand_expr(\n                            identified_estimand\n                        )\n                    except:\n                        estimand_identifier = None\n                    if (\n                        estimand_identifier is not None\n                        and estimand_identifier in self.ATE_cache\n                    ):\n                        return self.ATE_cache[estimand_identifier]\n\n                    timings.append(datetime.now())\n                    estimate = model.estimate_effect(\n                        identified_estimand,\n                        method_name=\"backdoor.linear_regression\",\n                        test_significance=True,\n                    )\n                    timings.append(datetime.now())\n                    p_value = (\n                        estimate.test_stat_significance()[\"p_value\"].astype(float)[\n                            0\n                        ]\n                        if calculate_p_value\n                        else None\n                    )\n                    timings.append(datetime.now())\n                    stderr = (\n                        estimate.get_standard_error()\n                        if calculate_std_error\n                        else None\n                    )\n                    timings.append(datetime.now())\n                    d = {\n                        \"ATE\": float(estimate.value),\n                        \"P-value\": p_value,\n                        \"Standard Error\": stderr,\n                    }\n                    if get_estimand:\n                        d[\"Estimand\"] = identified_estimand\n                    if estimand_identifier is not None:\n                        self.ATE_cache[estimand_identifier] = d\n\n            except:\n                raise ValueError\n\n    timings.append(datetime.now())\n    if print_timing_info:\n        print(\"\\tTimings:\")\n        for i in range(1, len(timings)):\n            print(f\"\\t\\tStep {i}: {timings[i] - timings[i-1]}\")\n\n    return d\n</code></pre>"},{"location":"reference/eccs/eccs/","title":"ECCS","text":""},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS","title":"<code>ECCS</code>","text":"<p>A class for managing the Exposing Critical Causal Structures (ECCS) algorithm.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>class ECCS:\n    \"\"\"\n    A class for managing the Exposing Critical Causal Structures (ECCS) algorithm.\n    \"\"\"\n\n    EDGE_SUGGESTION_METHODS = [\n        \"best_single_edge_change\",\n        \"best_single_adjustment_set_change_opt\",\n        \"best_single_adjustment_set_change\",\n        \"astar_single_edge_change\",\n        \"random_single_edge_change\",\n    ]\n    A_STAR_NUM_SUGGESTIONS_PER_INVOCATION = 2\n\n    def __init__(self, data: str | pd.DataFrame, graph: str | nx.DiGraph):\n        \"\"\"\n        Initialize the ECCS object.\n\n        Parameters:\n            data: The dataset or the path to it.\n            graph: The causal DAG, or a path to a file containing the graph in DOT format.\n        \"\"\"\n\n        # Load data appropriately\n        if isinstance(data, str):\n            self._data = pd.read_csv(data)\n        else:\n            self._data = data\n\n        self._num_vars = self._data.shape[1]\n        self._edge_states = EdgeStateMatrix(list(self._data.columns))\n\n        self.ate_calculator = ATECalculator()\n        self._cached_edit_options = []\n        self._cached_furthest_ate = 0\n        self._cached_acceptance_test = None\n        self._ate_cache = {}  # maps hashes of adjacency matrices to ate values\n\n        # Load graph appropriately\n        if isinstance(graph, str):\n            graph = nx.DiGraph(nx.nx_pydot.read_dot(graph))\n\n        self._graph = nx.DiGraph()\n        self._graph.add_nodes_from((n, {\"var_name\": n}) for n in graph.nodes)\n        for edge in graph.edges():\n            self.add_edge(edge[0], edge[1])\n\n        # Ban self edges.\n        for i in range(self._num_vars):\n            self.ban_edge(self._data.columns[i], self._data.columns[i])\n\n        print(\"Initialized ECCS!\")\n        print(\n            f\"The graph has {self._graph.number_of_nodes()} nodes and {self._graph.number_of_edges()} edges.\"\n        )\n        num_fixed_edges = len(self._edge_states.fixed_list)\n        num_banned_edges = len(self._edge_states.ban_list)\n        print(\n            f\"Of the {self._graph.number_of_edges()} edges in the graph, {num_fixed_edges} are fixed.\"\n        )\n        print(\n            f\"Of the {self._num_vars**2 - self._graph.number_of_edges()} edges not in the graph, {num_banned_edges} are banned.\"\n        )\n        print(\n            f\"The number of modifiable edges is {self._num_vars**2 - num_fixed_edges - num_banned_edges}.\"\n        )\n\n    def set_treatment(self, treatment: str) -&gt; None:\n        \"\"\"\n        Set the treatment variable.\n\n        Parameters:\n            treatment: The name of the treatment variable.\n        \"\"\"\n        self._treatment = treatment\n        self._treatment_idx = self._data.columns.get_loc(treatment)\n\n    def set_outcome(self, outcome: str) -&gt; None:\n        \"\"\"\n        Set the outcome variable.\n\n        Parameters:\n            outcome: The name of the outcome variable.\n        \"\"\"\n        self._outcome = outcome\n        self._outcome_idx = self._data.columns.get_loc(outcome)\n\n    @property\n    def data(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns the data.\n        \"\"\"\n        return self._data\n\n    @property\n    def banlist_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns the banlist as a dataframe, except for self edges\n        \"\"\"\n        banlist = self._edge_states.ban_list\n        banlist_df = pd.DataFrame(banlist, columns=[\"Source\", \"Destination\"])\n        banlist_df = banlist_df[banlist_df[\"Source\"] != banlist_df[\"Destination\"]]\n        return banlist_df\n\n    @property\n    def treatment(self) -&gt; str:\n        \"\"\"\n        Returns the treatment variable.\n        \"\"\"\n        return self._treatment\n\n    @property\n    def outcome(self) -&gt; str:\n        \"\"\"\n        Returns the outcome variable.\n        \"\"\"\n        return self._outcome\n\n    @property\n    def vars(self) -&gt; list[str]:\n        \"\"\"\n        Returns the list of variables in the data.\n        \"\"\"\n        return list(self._data.columns)\n\n    @property\n    def num_vars(self) -&gt; int:\n        \"\"\"\n        Calculate the number of variables in the data.\n\n        Returns:\n            The number of variables in the data.\n        \"\"\"\n        return len(self.vars)\n\n    @property\n    def graph(self) -&gt; nx.DiGraph:\n        \"\"\"\n        Returns the graph.\n        \"\"\"\n        return self._graph\n\n    def _is_acceptable(self, graph: Optional[nx.DiGraph]) -&gt; bool:\n        \"\"\"\n        Check if graph is acceptable. A graph is acceptable if it satisfies the following conditions:\n        - It is a directed acyclic graph.\n        - It includes the treatment and outcome variables.\n        - There is a directed path from the treatment to the outcome.\n        - It includes no banned edges.\n        - It includes all fixed edges.\n        The conditions are checked in order of expense, so that the most expensive checks are only performed if the\n        less expensive checks pass.\n\n        Parameters:\n            graph: The graph to check. If None, self.graph is checked.\n\n        Returns:\n            True if the graph is acceptable, False otherwise.\n        \"\"\"\n        if graph is None:\n            graph = self.graph\n\n        is_acceptable = (\n            self.treatment in graph.nodes  # It includes the treatment.\n            and self.outcome in graph.nodes  # It includes the outcome.\n            and all(  # It includes no banned edges.\n                not self._edge_states.is_edge_banned(src, dst)\n                for src, dst in graph.edges\n            )\n            and all(  # It includes all fixed edges.\n                graph.has_edge(src, dst) for src, dst in self._edge_states.fixed_list\n            )\n            and nx.is_directed_acyclic_graph(graph)  # It is a directed acyclic graph.\n        )\n\n        return is_acceptable\n\n    def clear_graph(self, clear_edge_states: bool = True) -&gt; None:\n        \"\"\"\n        Clear the graph and possibly edge states.\n\n        Parameters:\n            clear_edge_states: Whether to also clear the edge states.\n        \"\"\"\n        self._graph = nx.DiGraph()\n        if clear_edge_states:\n            self._edge_states = EdgeStateMatrix(list(self._data.columns))\n\n    def display_graph(self) -&gt; None:\n        \"\"\"\n        Display the current graph.\n        \"\"\"\n        GraphRenderer.display_graph(self._graph, self._edge_states)\n\n    def draw_graph(self) -&gt; str:\n        \"\"\"\n        Draw the current graph.\n\n        Returns:\n            A base64-encoded string representation of the graph.\n        \"\"\"\n        return GraphRenderer.draw_graph(self._graph, self._edge_states)\n\n    def save_graph(self, filename: str) -&gt; None:\n        \"\"\"\n        Save the current graph to a file.\n\n        Parameters:\n            filename: The name of the file to save to.\n        \"\"\"\n        GraphRenderer.save_graph(self._graph, self._edge_states, filename)\n\n    def add_edge(self, src: str, dst: str, is_suggested: bool = False) -&gt; bool:\n        \"\"\"\n        Add an edge to the graph and mark it as present, or as suggested if `is_suggested`\n        is True. Can only add an edge if its current state is absent.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n            is_suggested: Whether the edge addition is suggested by the system, as opposed\n                to being manually added by the user.\n\n        Returns:\n            True if the edge was indeed added, False otherwise.\n        \"\"\"\n        if self._edge_states.is_edge_in_state(src, dst, EdgeState.ABSENT):\n            self._graph.add_node(src, var_name=src)\n            self._graph.add_node(dst, var_name=dst)\n            self._graph.add_edge(src, dst)\n            target_state = EdgeState.SUGGESTED if is_suggested else EdgeState.PRESENT\n            self._edge_states.mark_edge(src, dst, target_state)\n            return True\n        return False\n\n    def remove_edge(self, src: str, dst: str, remove_isolates: bool = False) -&gt; bool:\n        \"\"\"\n        Remove an edge from the graph and then optionally remove any nodes with degree zero.\n        Can only remove an edge if its current state is present.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n            remove_isolates: Whether to remove any nodes with degree zero after removing the edge.\n\n        Returns:\n            True if the edge was indeed removed, False otherwise.\n        \"\"\"\n        if self._edge_states.is_edge_in_state(\n            src, dst, EdgeState.PRESENT\n        ) or self._edge_states.is_edge_in_state(src, dst, EdgeState.SUGGESTED):\n            self._graph.remove_edge(src, dst)\n            if remove_isolates:\n                self._graph.remove_nodes_from(list(nx.isolates(self._graph)))\n            self._edge_states.mark_edge(src, dst, EdgeState.ABSENT)\n            return True\n        return False\n\n    def get_edge_state(self, src: str, dst: str) -&gt; EdgeState:\n        \"\"\"\n        Get the state of an edge.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n\n        Returns:\n            The state of the edge.\n        \"\"\"\n        return self._edge_states.get_edge_state(src, dst)\n\n    def fix_edge(self, src: str, dst: str) -&gt; bool:\n        \"\"\"\n        Mark an edge as fixed.\n        Can only fix an edge if its current state is present.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n\n        Returns:\n            True if the edge was indeed fixed, False otherwise.\n        \"\"\"\n\n        if self._edge_states.is_edge_in_state(src, dst, EdgeState.PRESENT):\n            self._edge_states.mark_edge(src, dst, EdgeState.FIXED)\n            return True\n        return False\n\n    def ban_edge(self, src: str, dst: str) -&gt; bool:\n        \"\"\"\n        Mark an edge as banned.\n        Can only ban an edge if its current state is absent.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n\n        Returns:\n            True if the edge was indeed banned, False otherwise.\n        \"\"\"\n        if self._edge_states.is_edge_in_state(src, dst, EdgeState.ABSENT):\n            self._edge_states.mark_edge(src, dst, EdgeState.BANNED)\n            return True\n        return False\n\n    def unban_edge(self, src: str, dst: str) -&gt; None:\n        \"\"\"\n        Mark a banned edge as absent, as long as its reverse is not fixed.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n        \"\"\"\n        if self._edge_states.is_edge_in_state(\n            src, dst, EdgeState.BANNED\n        ) and not self._edge_states.is_edge_in_state(dst, src, EdgeState.FIXED):\n            self._edge_states.mark_edge(src, dst, EdgeState.ABSENT)\n\n    def unfix_edge(self, src: str, dst: str) -&gt; None:\n        \"\"\"\n        Mark a fixed edge as present and its (previously banned) reverse as absent.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n        \"\"\"\n        if self._edge_states.is_edge_in_state(src, dst, EdgeState.FIXED):\n            self._edge_states.mark_edge(src, dst, EdgeState.PRESENT)\n            self._edge_states.mark_edge(dst, src, EdgeState.ABSENT)\n\n    def is_edge_fixed(self, src: str, dst: str) -&gt; bool:\n        \"\"\"\n        Check if an edge is fixed.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n\n        Returns:\n            True if the edge is fixed, False otherwise.\n        \"\"\"\n        return self._edge_states.is_edge_in_state(src, dst, EdgeState.FIXED)\n\n    def is_edge_banned(self, src: str, dst: str) -&gt; bool:\n        \"\"\"\n        Check if an edge is banned.\n\n        Parameters:\n            src: The name of the source variable.\n            dst: The name of the destination variable.\n\n        Returns:\n            True if the edge is banned, False otherwise.\n        \"\"\"\n        return self._edge_states.is_edge_in_state(src, dst, EdgeState.BANNED)\n\n    @staticmethod\n    def hash_graph(graph: nx.DiGraph) -&gt; int:\n        \"\"\"\n        Hash a graph.\n\n        Parameters:\n            graph: The graph to hash.\n\n        Returns:\n            The hash of the graph.\n        \"\"\"\n        adj_matrix = nx.adjacency_matrix(graph)\n        return hash(\n            (\n                tuple(adj_matrix.data),\n                tuple(adj_matrix.indices),\n                tuple(adj_matrix.indptr),\n            )\n        )\n\n    def get_ate(\n        self,\n        graph: Optional[nx.DiGraph] = None,\n    ) -&gt; float:\n        \"\"\"\n        Calculate the average treatment effect (ATE) of `self._treatment` on `self._outcome` given `graph`.\n        If graph is not provided, `self._graph` is used.\n\n        Parameters:\n            graph: The graph to use for the calculation.\n\n        Returns:\n            The ATE.\n        \"\"\"\n\n        if graph is None:\n            graph = self._graph\n        graph_hash = ECCS.hash_graph(graph)\n        if graph_hash not in self._ate_cache:\n            self._ate_cache[graph_hash] = self.ate_calculator.get_ate_and_confidence(\n                self.data, treatment=self._treatment, outcome=self._outcome, graph=graph\n            )[\"ATE\"]\n        return self._ate_cache[graph_hash]\n\n    def suggest(\n        self, method: str, budget: Optional[int] = None, max_results: int = None\n    ) -&gt; tuple[list[EdgeEdit], float, int]:\n        \"\"\"\n        Suggest a modification to the graph that yields a maximally different ATE,\n        compared to the current ATE. The modification should not edit edges that are\n        currently fixed or banned. The method used for suggestion is specified by `method`.\n\n        Parameters:\n            method: The method to use for suggestion. Must be in ECCS.EDGE_SUGGESTION_METHODS.\n            budget: The budget for finding a suggestion. Not all methods use this.\n            max_results: The maximum number of edits to return. The rest, if any, may be cached.\n                If None, all suggested edits are returned.\n\n        Returns:\n          A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n          if the underlying algorithm was invoked anew, the total number of edits it produced.\n\n        Raises:\n            ValueError: If `method` is not in ECCS.EDGE_SUGGESTION_METHODS.\n        \"\"\"\n\n        if method not in ECCS.EDGE_SUGGESTION_METHODS:\n            raise ValueError(f\"Invalid method: {method}\")\n\n        if method == \"best_single_edge_change\":\n            return self.suggest_best_single_edge_change()\n        elif method == \"best_single_adjustment_set_change\":\n            return self.suggest_best_single_adjustment_set_change(\n                max_results=max_results, use_optimized=False\n            )\n        elif method == \"best_single_adjustment_set_change_opt\":\n            return self.suggest_best_single_adjustment_set_change(\n                max_results=max_results, use_optimized=True\n            )\n        elif method == \"random_single_edge_change\":\n            return self.suggest_random_single_edge_change()\n        elif method == \"astar_single_edge_change\":\n            return self.suggest_best_single_edge_change_heuristic(\n                budget, max_results=max_results\n            )\n\n    def _edit_and_get_ate(self, edits: list[EdgeEdit]) -&gt; Optional[float]:\n        \"\"\"\n        Edit a copy of the current self.graph according to `edits` and evaluate the ATE.\n        Does not modify self.graph.\n\n        Parameters:\n            edits: A list of edits to be made to the graph.\n\n        Returns:\n            The ATE, or None if the graph is not acceptable.\n        \"\"\"\n\n        graph = self._graph.copy()\n\n        # Edit graph\n        for src, dst, edit_type in edits:\n            print(\"Applying edit: \", src, dst, edit_type)\n            if edit_type == EdgeEditType.ADD:\n                if not graph.has_edge(src, dst):\n                    graph.add_edge(src, dst)\n            elif edit_type == EdgeEditType.REMOVE:\n                if graph.has_edge(src, dst):\n                    graph.remove_edge(src, dst)\n            elif edit_type == EdgeEditType.FLIP:\n                if graph.has_edge(src, dst):\n                    graph.remove_edge(src, dst)\n                if not graph.has_edge(dst, src):\n                    graph.add_edge(dst, src)\n\n        print(\"Applied edits successfully\")\n\n        # Compute the ATE if the graph is acceptable\n        if self._is_acceptable(graph):\n            print(\"Graph is acceptable after edits: \", edits)\n            ate = self.get_ate(graph)\n            print(\"Got back ATE: \", ate)\n            return ate\n\n        print(\"Graph is not acceptable after edits: \", edits)\n        return None\n\n    def _edit_and_draw(self, edits: list[EdgeEdit]) -&gt; Optional[str]:\n        \"\"\"\n        Edit a copy of the current self.graph according to `edits` and draw the graph.\n        Parameters:\n            edits: A list of edits to be made to the graph.\n\n        Returns:\n            A base64-encoded string representation of the graph, or None if the graph is not acceptable.\n        \"\"\"\n\n        graph = self._graph.copy()\n        edge_decisions_matrix = self._edge_states.copy()\n\n        # Edit graph\n        for src, dst, edit_type in edits:\n            if edit_type == EdgeEditType.ADD:\n                graph.add_edge(src, dst)\n                edge_decisions_matrix.mark_edge(src, dst, EdgeState.SUGGESTED)\n            elif edit_type == EdgeEditType.REMOVE:\n                graph.remove_edge(src, dst)\n                edge_decisions_matrix.mark_edge(src, dst, EdgeState.ABSENT)\n            elif edit_type == EdgeEditType.FLIP:\n                graph.remove_edge(src, dst)\n                edge_decisions_matrix.mark_edge(src, dst, EdgeState.ABSENT)\n                graph.add_edge(dst, src)\n                edge_decisions_matrix.mark_edge(dst, src, EdgeState.SUGGESTED)\n\n        # Draw the graph if the graph is acceptable\n        if not self._is_acceptable(graph):\n            return None\n\n        return GraphRenderer.draw_graph(graph, edge_decisions_matrix)\n\n    def suggest_best_single_edge_change(\n        self,\n    ) -&gt; Tuple[list[EdgeEdit], float, int]:\n        \"\"\"\n        Suggest the best_single_edge_change that maximally changes the ATE.\n\n        Returns:\n            A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n                if the underlying algorithm was invoked anew, the total number of edits it produced.\n        \"\"\"\n        base_ate = self.get_ate()\n        furthest_ate = base_ate\n        best_ate_diff = 0\n        best_edits = []\n\n        def maybe_update_best(ate, edits):\n            nonlocal best_ate_diff\n            nonlocal furthest_ate\n            nonlocal best_edits\n\n            if ate is None:\n                return\n            ate_diff = abs(ate - base_ate)\n            if ate_diff &gt; best_ate_diff:\n                best_ate_diff = ate_diff\n                furthest_ate = ate\n                best_edits = edits\n\n        pairs = list(combinations(range(self._num_vars), 2))\n\n        # Iterate over all unordered pairs of variables and compute ates\n        for i, j in pairs:\n\n            # Extract edge endpoints and if none of the two are in the graph, skip\n            e1 = self._data.columns[i]\n            e2 = self._data.columns[j]\n\n            # Extract edge states\n            f_state = self.get_edge_state(e1, e2)\n            r_state = self.get_edge_state(e2, e1)\n\n            # Apply the change and evaluate the ATE\n            if f_state == EdgeState.ABSENT and (\n                r_state == EdgeState.ABSENT or r_state == EdgeState.BANNED\n            ):\n                # Try adding in the \"forward\" direction\n                ate = self._edit_and_get_ate([EdgeEdit(e1, e2, EdgeEditType.ADD)])\n                maybe_update_best(ate, [EdgeEdit(e1, e2, EdgeEditType.ADD)])\n            if r_state == EdgeState.ABSENT and (\n                f_state == EdgeState.ABSENT or f_state == EdgeState.BANNED\n            ):\n                # Try adding in the \"reverse\" direction\n                ate = self._edit_and_get_ate([EdgeEdit(e2, e1, EdgeEditType.ADD)])\n                maybe_update_best(ate, [EdgeEdit(e2, e1, EdgeEditType.ADD)])\n            if f_state == EdgeState.PRESENT:\n                # Try removing the edge\n                ate = self._edit_and_get_ate([EdgeEdit(e1, e2, EdgeEditType.REMOVE)])\n                maybe_update_best(ate, [EdgeEdit(e1, e2, EdgeEditType.REMOVE)])\n                if r_state == EdgeState.ABSENT:  # As opposed to banned\n                    # Try flipping the edge\n                    ate = self._edit_and_get_ate([EdgeEdit(e1, e2, EdgeEditType.FLIP)])\n                    maybe_update_best(ate, [EdgeEdit(e1, e2, EdgeEditType.FLIP)])\n            if r_state == EdgeState.PRESENT:\n                # Try removing the edge\n                ate = self._edit_and_get_ate([EdgeEdit(e2, e1, EdgeEditType.REMOVE)])\n                maybe_update_best(ate, [EdgeEdit(e2, e1, EdgeEditType.REMOVE)])\n                if f_state == EdgeState.ABSENT:  # As opposed to banned\n                    # Try flipping the edge\n                    ate = self._edit_and_get_ate([EdgeEdit(e2, e1, EdgeEditType.FLIP)])\n                    maybe_update_best(ate, [EdgeEdit(e2, e1, EdgeEditType.FLIP)])\n\n        return (best_edits, furthest_ate, 1)\n\n    @staticmethod\n    def _pop_n(l: list[Any], n: int) -&gt; list[Any]:\n        \"\"\"\n        Pop `n` elements from the start of list `l` and return them as a list.\n\n        Parameters:\n            l: The list to pop from.\n            n: The number of elements to pop.\n\n        Returns:\n            The popped elements.\n        \"\"\"\n        elements = l[:n]\n        l[:] = l[n:]\n        return elements\n\n    def suggest_best_single_edge_change_heuristic(\n        self, budget: Optional[int] = None, max_results: int = None\n    ) -&gt; Tuple[list[EdgeEdit], float, int]:\n        \"\"\"\n        Suggest the best single edge change based on A star\n\n        Parameters:\n            budget: The budget for the search.\n            max_results: The maximum number of edits to return. The rest, if any, are cached.\n                If None, all suggested edits are returned.\n\n        Returns:\n            A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n                if the underlying algorithm was invoked anew, the total number of edits it produced.\n        \"\"\"\n        if len(self._cached_edit_options) &gt; 0:\n            edits = ECCS._pop_n(self._cached_edit_options, max_results)\n            return (edits, self._edit_and_get_ate(edits), 0)\n        a_star = AStarSearch(\n            self._graph,\n            self._treatment,\n            self._outcome,\n            self._data,\n            self._edge_states,\n            computational_budget=budget,\n        )\n        edits = a_star.astar()\n        self._cached_edit_options = edits[: self.A_STAR_NUM_SUGGESTIONS_PER_INVOCATION]\n        edits = ECCS._pop_n(self._cached_edit_options, max_results)\n        res = (\n            edits,\n            self._edit_and_get_ate(edits),\n            self.A_STAR_NUM_SUGGESTIONS_PER_INVOCATION,\n        )\n\n        # return ([edit], self._edit_and_get_ate([edit]), True) # TODO: FIXME\n        return res\n\n    @staticmethod\n    def _find_adjustment_set(\n        graph: nx.DiGraph,\n        treatment: str,\n        outcome: str,\n    ) -&gt; list[str]:\n        \"\"\"\n        Find an adjustment set between the treatment and outcome variables in the graph.\n        We achieve this by only leaving backdoor paths in the graph, by temporarily removing\n        all edges that are directed out from the treatment variable.\n\n        Parameters:\n            graph: The graph to search.\n            treatment: The treatment variable.\n            outcome: The outcome variable.\n\n        Returns:\n            The adjustment set, or None if no adjustment set exists.\n        \"\"\"\n        temp_removed_edges = list(graph.out_edges(treatment))\n        for edge in temp_removed_edges:\n            graph.remove_edge(edge[0], edge[1])\n        adjset = nx.algorithms.find_minimal_d_separator(graph, treatment, outcome)\n        for edge in temp_removed_edges:\n            graph.add_edge(edge[0], edge[1])\n        return adjset\n\n    def suggest_best_single_adjustment_set_change(\n        self, max_results: int = None, use_optimized: bool = True\n    ) -&gt; Tuple[list[EdgeEdit], float, int]:\n        \"\"\"\n        Suggest the best_single_adjustment_set_changes that maximally changes the ATE.\n\n        Parameters:\n            max_results: The maximum number of edits to return. The rest, if any, are cached.\n                If None, all suggested edits are returned.\n            use_optimized: Whether to use the optimized version of the algorithm.\n\n        Returns:\n            A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n                if the underlying algorithm was invoked anew, the total number of edits it produced.\n        \"\"\"\n        print(\"Computing and suggesting best single adjustment set change\")\n        print(\n            f\"The current cache size is {len(self._cached_edit_options)} and the acceptance test returns {self._cached_acceptance_test}\"\n        )\n\n        if len(self._cached_edit_options) &gt; 0 and self._cached_acceptance_test():\n            print(\n                \"Serving previous edge suggestion(s) based on best single adjustment set change\"\n            )\n            edits = ECCS._pop_n(self._cached_edit_options, max_results)\n            self._cached_acceptance_test = self._check_if_edits_were_accepted(edits)\n            return (edits, self._cached_furthest_ate, 0)\n\n        ranking = self.get_adj_set_changes_ranking(use_optimized=use_optimized, k=1)\n\n        print(\"Done evaluating options\")\n        if len(ranking) == 0:\n            return ([], self.get_ate(), 0)\n\n        _, best_edits, furthest_ate, _ = ranking[0]\n        num_best_edits = len(best_edits)\n\n        if num_best_edits == 0:\n            return ([], furthest_ate, 0)\n        elif (max_results is None) or (\n            num_best_edits &lt;= max_results\n        ):  # No need to cache edits\n            self._cached_furthest_ate = furthest_ate\n            self._cached_edit_options = []\n            self._cached_acceptance_test = None\n            return (best_edits, furthest_ate, num_best_edits)\n        else:  # Must cache some edits\n            self._cached_furthest_ate = furthest_ate\n            self._cached_edit_options = best_edits\n            edits_to_return = ECCS._pop_n(self._cached_edit_options, max_results)\n            self._cached_acceptance_test = self._check_if_edits_were_accepted(\n                edits_to_return\n            )\n            return (edits_to_return, furthest_ate, num_best_edits)\n\n    def get_adj_set_changes_ranking(\n        self,\n        use_optimized: bool = True,\n        k: Optional[int] = None,\n        min_ate_ratio: Optional[float] = None,\n    ) -&gt; list[tuple[str, list[EdgeEdit], float]]:\n        \"\"\"\n        Get a ranking of single-variable adjustment set changes, based on their\n        impact on the ATE. Can filter by number of variables to return (`k`) and/or\n        by the minimum relative change in ATE.\n\n        Parameters:\n            use_optimized: Whether to use the optimized version of the algorithm.\n            k: The maximum number of changes to return. If None, all are returned.\n            min_ate_ratio: The minimum relative change in ATE to return. If None, all are returned.\n\n        Returns:\n            A list of tuples, each containing the variable that was changed, the corresponding edge edit(s),\n                and the resulting ATE.\n        \"\"\"\n        base_ate = self.get_ate()\n\n        ranking = []\n        # Each element has (variable, edits, ate, ate_ratio)\n\n        def maybe_update_ranking(v, edits, ate):\n            nonlocal ranking\n\n            # If the ate couldn't be computed, return\n            if ate is None:\n                return\n\n            # If the achieved ate ratio is below cutoff, return\n            ate_ratio = abs((ate - base_ate) / base_ate)\n            if (min_ate_ratio is not None) and (ate_ratio &lt; min_ate_ratio):\n                return\n\n            # If the ranking is full and the achieved ate ratio is below the\n            # worst in the ranking, return\n            if (\n                (k is not None)\n                and (len(ranking) == k)\n                and (ate_ratio &lt;= ranking[-1][3])\n            ):\n                return\n\n            # Insert the new element in the right position in the ranking and trim\n            # down to desired length if needed.\n            inserted = False\n            for i, (_, _, _, r) in enumerate(ranking):\n                if ate_ratio &gt; r:\n                    ranking.insert(i, (v, edits, ate, ate_ratio))\n                    inserted = True\n                    break\n            if not inserted:\n                ranking.append((v, edits, ate, ate_ratio))\n\n            if (k is not None) and (len(ranking) &gt; k):\n                ranking.pop()\n\n        base_adj_set = ECCS._find_adjustment_set(\n            self._graph, self.treatment, self.outcome\n        )\n        print(\"Found base adjustment set: \", base_adj_set)\n        vars_not_in_adj_set = [\n            v\n            for v in self.vars\n            if v not in base_adj_set and v != self.treatment and v != self.outcome\n        ]\n\n        mapper = MapAdjSetToGraph(\n            self.graph,\n            self.treatment,\n            self.outcome,\n            self._edge_states.fixed_list,\n            self._edge_states.ban_list,\n            base_adj_set,\n        )\n\n        # Try adding each of the addable\n        for v in vars_not_in_adj_set:\n            print(f\"Trying to add {v} to the adjustment set\")\n            edits = mapper.map_addition(v, use_optimized)\n            print(\"Got back edits for addition: \", edits)\n            ate = self._edit_and_get_ate(edits)\n            maybe_update_ranking(v, edits, ate)\n\n        # Try removing each of the removable\n        for v in base_adj_set:\n            print(f\"Trying to remove {v} from the adjustment set\")\n            edits = mapper.map_removal(v, use_optimized)\n            print(\"Got back edit lists for removal: \", edits)\n            ate = self._edit_and_get_ate(edits)\n            maybe_update_ranking(v, edits, ate)\n\n        return ranking\n\n    def _check_if_edits_were_accepted(\n        self, edits: list[EdgeEdit]\n    ) -&gt; Callable[[], bool]:\n        \"\"\"\n        Given a list of edits, return a lambda that will evaluate True if those edits could be the most\n        recent edits to have been applied to self._graph.\n\n        Parameters:\n            edits: The edits to evaluate.\n\n        Returns:\n            A lambda that will evaluate true if the edits could be the most\n            recent edits to have been applied to self._graph.\n        \"\"\"\n        lambdas = []\n        for src, dst, edit_type in edits:\n            if edit_type == EdgeEditType.ADD:\n                lambdas.append(lambda: self.graph.has_edge(src, dst))\n            elif edit_type == EdgeEditType.REMOVE:\n                lambdas.append(lambda: (not self.graph.has_edge(src, dst)))\n            elif edit_type == EdgeEditType.FLIP:\n                lambdas.append(\n                    lambda: (\n                        self.graph.has_edge(dst, src)\n                        and not self.graph.has_edge(src, dst)\n                    )\n                )\n\n        return lambda: all([l() for l in lambdas])\n\n    def suggest_random_single_edge_change(\n        self,\n    ) -&gt; Tuple[list[EdgeEdit], float, int]:\n        \"\"\"\n        Suggest a random_single_edge_change.\n\n        Returns:\n            A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n            if the underlying algorithm was invoked anew, the total number of edits it produced.\n        \"\"\"\n\n        # Derive the set of editable edges\n        eligible_pairs = list(combinations(range(self._num_vars), 2))\n        eligible_edges = [\n            (self._data.columns[i], self._data.columns[j]) for i, j in eligible_pairs\n        ]\n        eligible_edges = [\n            (src, dst)\n            for src, dst in eligible_edges\n            if src != dst  # Don't toggle self-edges\n            and not self.is_edge_fixed(src, dst)  # Don't touch fixed edges\n            and not self.is_edge_fixed(\n                dst, src\n            )  # No point toggling if reverse is fixed.\n            and not self.is_edge_banned(src, dst)  # Don't touch banned edges\n        ]\n\n        while len(eligible_edges) &gt; 0:\n            e1, e2 = eligible_edges.pop(np.random.randint(len(eligible_edges)))\n\n            edit = ()\n            if self.get_edge_state(e1, e2) == EdgeState.ABSENT:\n                edit = EdgeEdit(e1, e2, EdgeEditType.ADD)\n            else:\n                edit = EdgeEdit(e1, e2, EdgeEditType.REMOVE)\n\n            ate = self._edit_and_get_ate([edit])\n\n            if ate == None:\n                continue\n\n            return ([edit], ate, 1)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.data","title":"<code>data: pd.DataFrame</code>  <code>property</code>","text":"<p>Returns the data.</p>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.banlist_df","title":"<code>banlist_df: pd.DataFrame</code>  <code>property</code>","text":"<p>Returns the banlist as a dataframe, except for self edges</p>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.treatment","title":"<code>treatment: str</code>  <code>property</code>","text":"<p>Returns the treatment variable.</p>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.outcome","title":"<code>outcome: str</code>  <code>property</code>","text":"<p>Returns the outcome variable.</p>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.vars","title":"<code>vars: list[str]</code>  <code>property</code>","text":"<p>Returns the list of variables in the data.</p>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.num_vars","title":"<code>num_vars: int</code>  <code>property</code>","text":"<p>Calculate the number of variables in the data.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of variables in the data.</p>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.graph","title":"<code>graph: nx.DiGraph</code>  <code>property</code>","text":"<p>Returns the graph.</p>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.__init__","title":"<code>__init__(data, graph)</code>","text":"<p>Initialize the ECCS object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | DataFrame</code> <p>The dataset or the path to it.</p> required <code>graph</code> <code>str | DiGraph</code> <p>The causal DAG, or a path to a file containing the graph in DOT format.</p> required Source code in <code>src/eccs/eccs.py</code> <pre><code>def __init__(self, data: str | pd.DataFrame, graph: str | nx.DiGraph):\n    \"\"\"\n    Initialize the ECCS object.\n\n    Parameters:\n        data: The dataset or the path to it.\n        graph: The causal DAG, or a path to a file containing the graph in DOT format.\n    \"\"\"\n\n    # Load data appropriately\n    if isinstance(data, str):\n        self._data = pd.read_csv(data)\n    else:\n        self._data = data\n\n    self._num_vars = self._data.shape[1]\n    self._edge_states = EdgeStateMatrix(list(self._data.columns))\n\n    self.ate_calculator = ATECalculator()\n    self._cached_edit_options = []\n    self._cached_furthest_ate = 0\n    self._cached_acceptance_test = None\n    self._ate_cache = {}  # maps hashes of adjacency matrices to ate values\n\n    # Load graph appropriately\n    if isinstance(graph, str):\n        graph = nx.DiGraph(nx.nx_pydot.read_dot(graph))\n\n    self._graph = nx.DiGraph()\n    self._graph.add_nodes_from((n, {\"var_name\": n}) for n in graph.nodes)\n    for edge in graph.edges():\n        self.add_edge(edge[0], edge[1])\n\n    # Ban self edges.\n    for i in range(self._num_vars):\n        self.ban_edge(self._data.columns[i], self._data.columns[i])\n\n    print(\"Initialized ECCS!\")\n    print(\n        f\"The graph has {self._graph.number_of_nodes()} nodes and {self._graph.number_of_edges()} edges.\"\n    )\n    num_fixed_edges = len(self._edge_states.fixed_list)\n    num_banned_edges = len(self._edge_states.ban_list)\n    print(\n        f\"Of the {self._graph.number_of_edges()} edges in the graph, {num_fixed_edges} are fixed.\"\n    )\n    print(\n        f\"Of the {self._num_vars**2 - self._graph.number_of_edges()} edges not in the graph, {num_banned_edges} are banned.\"\n    )\n    print(\n        f\"The number of modifiable edges is {self._num_vars**2 - num_fixed_edges - num_banned_edges}.\"\n    )\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.set_treatment","title":"<code>set_treatment(treatment)</code>","text":"<p>Set the treatment variable.</p> <p>Parameters:</p> Name Type Description Default <code>treatment</code> <code>str</code> <p>The name of the treatment variable.</p> required Source code in <code>src/eccs/eccs.py</code> <pre><code>def set_treatment(self, treatment: str) -&gt; None:\n    \"\"\"\n    Set the treatment variable.\n\n    Parameters:\n        treatment: The name of the treatment variable.\n    \"\"\"\n    self._treatment = treatment\n    self._treatment_idx = self._data.columns.get_loc(treatment)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.set_outcome","title":"<code>set_outcome(outcome)</code>","text":"<p>Set the outcome variable.</p> <p>Parameters:</p> Name Type Description Default <code>outcome</code> <code>str</code> <p>The name of the outcome variable.</p> required Source code in <code>src/eccs/eccs.py</code> <pre><code>def set_outcome(self, outcome: str) -&gt; None:\n    \"\"\"\n    Set the outcome variable.\n\n    Parameters:\n        outcome: The name of the outcome variable.\n    \"\"\"\n    self._outcome = outcome\n    self._outcome_idx = self._data.columns.get_loc(outcome)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS._is_acceptable","title":"<code>_is_acceptable(graph)</code>","text":"<p>Check if graph is acceptable. A graph is acceptable if it satisfies the following conditions: - It is a directed acyclic graph. - It includes the treatment and outcome variables. - There is a directed path from the treatment to the outcome. - It includes no banned edges. - It includes all fixed edges. The conditions are checked in order of expense, so that the most expensive checks are only performed if the less expensive checks pass.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Optional[DiGraph]</code> <p>The graph to check. If None, self.graph is checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the graph is acceptable, False otherwise.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def _is_acceptable(self, graph: Optional[nx.DiGraph]) -&gt; bool:\n    \"\"\"\n    Check if graph is acceptable. A graph is acceptable if it satisfies the following conditions:\n    - It is a directed acyclic graph.\n    - It includes the treatment and outcome variables.\n    - There is a directed path from the treatment to the outcome.\n    - It includes no banned edges.\n    - It includes all fixed edges.\n    The conditions are checked in order of expense, so that the most expensive checks are only performed if the\n    less expensive checks pass.\n\n    Parameters:\n        graph: The graph to check. If None, self.graph is checked.\n\n    Returns:\n        True if the graph is acceptable, False otherwise.\n    \"\"\"\n    if graph is None:\n        graph = self.graph\n\n    is_acceptable = (\n        self.treatment in graph.nodes  # It includes the treatment.\n        and self.outcome in graph.nodes  # It includes the outcome.\n        and all(  # It includes no banned edges.\n            not self._edge_states.is_edge_banned(src, dst)\n            for src, dst in graph.edges\n        )\n        and all(  # It includes all fixed edges.\n            graph.has_edge(src, dst) for src, dst in self._edge_states.fixed_list\n        )\n        and nx.is_directed_acyclic_graph(graph)  # It is a directed acyclic graph.\n    )\n\n    return is_acceptable\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.clear_graph","title":"<code>clear_graph(clear_edge_states=True)</code>","text":"<p>Clear the graph and possibly edge states.</p> <p>Parameters:</p> Name Type Description Default <code>clear_edge_states</code> <code>bool</code> <p>Whether to also clear the edge states.</p> <code>True</code> Source code in <code>src/eccs/eccs.py</code> <pre><code>def clear_graph(self, clear_edge_states: bool = True) -&gt; None:\n    \"\"\"\n    Clear the graph and possibly edge states.\n\n    Parameters:\n        clear_edge_states: Whether to also clear the edge states.\n    \"\"\"\n    self._graph = nx.DiGraph()\n    if clear_edge_states:\n        self._edge_states = EdgeStateMatrix(list(self._data.columns))\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.display_graph","title":"<code>display_graph()</code>","text":"<p>Display the current graph.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def display_graph(self) -&gt; None:\n    \"\"\"\n    Display the current graph.\n    \"\"\"\n    GraphRenderer.display_graph(self._graph, self._edge_states)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.draw_graph","title":"<code>draw_graph()</code>","text":"<p>Draw the current graph.</p> <p>Returns:</p> Type Description <code>str</code> <p>A base64-encoded string representation of the graph.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def draw_graph(self) -&gt; str:\n    \"\"\"\n    Draw the current graph.\n\n    Returns:\n        A base64-encoded string representation of the graph.\n    \"\"\"\n    return GraphRenderer.draw_graph(self._graph, self._edge_states)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.save_graph","title":"<code>save_graph(filename)</code>","text":"<p>Save the current graph to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save to.</p> required Source code in <code>src/eccs/eccs.py</code> <pre><code>def save_graph(self, filename: str) -&gt; None:\n    \"\"\"\n    Save the current graph to a file.\n\n    Parameters:\n        filename: The name of the file to save to.\n    \"\"\"\n    GraphRenderer.save_graph(self._graph, self._edge_states, filename)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.add_edge","title":"<code>add_edge(src, dst, is_suggested=False)</code>","text":"<p>Add an edge to the graph and mark it as present, or as suggested if <code>is_suggested</code> is True. Can only add an edge if its current state is absent.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required <code>is_suggested</code> <code>bool</code> <p>Whether the edge addition is suggested by the system, as opposed to being manually added by the user.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge was indeed added, False otherwise.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def add_edge(self, src: str, dst: str, is_suggested: bool = False) -&gt; bool:\n    \"\"\"\n    Add an edge to the graph and mark it as present, or as suggested if `is_suggested`\n    is True. Can only add an edge if its current state is absent.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n        is_suggested: Whether the edge addition is suggested by the system, as opposed\n            to being manually added by the user.\n\n    Returns:\n        True if the edge was indeed added, False otherwise.\n    \"\"\"\n    if self._edge_states.is_edge_in_state(src, dst, EdgeState.ABSENT):\n        self._graph.add_node(src, var_name=src)\n        self._graph.add_node(dst, var_name=dst)\n        self._graph.add_edge(src, dst)\n        target_state = EdgeState.SUGGESTED if is_suggested else EdgeState.PRESENT\n        self._edge_states.mark_edge(src, dst, target_state)\n        return True\n    return False\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.remove_edge","title":"<code>remove_edge(src, dst, remove_isolates=False)</code>","text":"<p>Remove an edge from the graph and then optionally remove any nodes with degree zero. Can only remove an edge if its current state is present.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required <code>remove_isolates</code> <code>bool</code> <p>Whether to remove any nodes with degree zero after removing the edge.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge was indeed removed, False otherwise.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def remove_edge(self, src: str, dst: str, remove_isolates: bool = False) -&gt; bool:\n    \"\"\"\n    Remove an edge from the graph and then optionally remove any nodes with degree zero.\n    Can only remove an edge if its current state is present.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n        remove_isolates: Whether to remove any nodes with degree zero after removing the edge.\n\n    Returns:\n        True if the edge was indeed removed, False otherwise.\n    \"\"\"\n    if self._edge_states.is_edge_in_state(\n        src, dst, EdgeState.PRESENT\n    ) or self._edge_states.is_edge_in_state(src, dst, EdgeState.SUGGESTED):\n        self._graph.remove_edge(src, dst)\n        if remove_isolates:\n            self._graph.remove_nodes_from(list(nx.isolates(self._graph)))\n        self._edge_states.mark_edge(src, dst, EdgeState.ABSENT)\n        return True\n    return False\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.get_edge_state","title":"<code>get_edge_state(src, dst)</code>","text":"<p>Get the state of an edge.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required <p>Returns:</p> Type Description <code>EdgeState</code> <p>The state of the edge.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def get_edge_state(self, src: str, dst: str) -&gt; EdgeState:\n    \"\"\"\n    Get the state of an edge.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n\n    Returns:\n        The state of the edge.\n    \"\"\"\n    return self._edge_states.get_edge_state(src, dst)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.fix_edge","title":"<code>fix_edge(src, dst)</code>","text":"<p>Mark an edge as fixed. Can only fix an edge if its current state is present.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge was indeed fixed, False otherwise.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def fix_edge(self, src: str, dst: str) -&gt; bool:\n    \"\"\"\n    Mark an edge as fixed.\n    Can only fix an edge if its current state is present.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n\n    Returns:\n        True if the edge was indeed fixed, False otherwise.\n    \"\"\"\n\n    if self._edge_states.is_edge_in_state(src, dst, EdgeState.PRESENT):\n        self._edge_states.mark_edge(src, dst, EdgeState.FIXED)\n        return True\n    return False\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.ban_edge","title":"<code>ban_edge(src, dst)</code>","text":"<p>Mark an edge as banned. Can only ban an edge if its current state is absent.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge was indeed banned, False otherwise.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def ban_edge(self, src: str, dst: str) -&gt; bool:\n    \"\"\"\n    Mark an edge as banned.\n    Can only ban an edge if its current state is absent.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n\n    Returns:\n        True if the edge was indeed banned, False otherwise.\n    \"\"\"\n    if self._edge_states.is_edge_in_state(src, dst, EdgeState.ABSENT):\n        self._edge_states.mark_edge(src, dst, EdgeState.BANNED)\n        return True\n    return False\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.unban_edge","title":"<code>unban_edge(src, dst)</code>","text":"<p>Mark a banned edge as absent, as long as its reverse is not fixed.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required Source code in <code>src/eccs/eccs.py</code> <pre><code>def unban_edge(self, src: str, dst: str) -&gt; None:\n    \"\"\"\n    Mark a banned edge as absent, as long as its reverse is not fixed.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n    \"\"\"\n    if self._edge_states.is_edge_in_state(\n        src, dst, EdgeState.BANNED\n    ) and not self._edge_states.is_edge_in_state(dst, src, EdgeState.FIXED):\n        self._edge_states.mark_edge(src, dst, EdgeState.ABSENT)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.unfix_edge","title":"<code>unfix_edge(src, dst)</code>","text":"<p>Mark a fixed edge as present and its (previously banned) reverse as absent.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required Source code in <code>src/eccs/eccs.py</code> <pre><code>def unfix_edge(self, src: str, dst: str) -&gt; None:\n    \"\"\"\n    Mark a fixed edge as present and its (previously banned) reverse as absent.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n    \"\"\"\n    if self._edge_states.is_edge_in_state(src, dst, EdgeState.FIXED):\n        self._edge_states.mark_edge(src, dst, EdgeState.PRESENT)\n        self._edge_states.mark_edge(dst, src, EdgeState.ABSENT)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.is_edge_fixed","title":"<code>is_edge_fixed(src, dst)</code>","text":"<p>Check if an edge is fixed.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge is fixed, False otherwise.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def is_edge_fixed(self, src: str, dst: str) -&gt; bool:\n    \"\"\"\n    Check if an edge is fixed.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n\n    Returns:\n        True if the edge is fixed, False otherwise.\n    \"\"\"\n    return self._edge_states.is_edge_in_state(src, dst, EdgeState.FIXED)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.is_edge_banned","title":"<code>is_edge_banned(src, dst)</code>","text":"<p>Check if an edge is banned.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The name of the source variable.</p> required <code>dst</code> <code>str</code> <p>The name of the destination variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge is banned, False otherwise.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def is_edge_banned(self, src: str, dst: str) -&gt; bool:\n    \"\"\"\n    Check if an edge is banned.\n\n    Parameters:\n        src: The name of the source variable.\n        dst: The name of the destination variable.\n\n    Returns:\n        True if the edge is banned, False otherwise.\n    \"\"\"\n    return self._edge_states.is_edge_in_state(src, dst, EdgeState.BANNED)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.hash_graph","title":"<code>hash_graph(graph)</code>  <code>staticmethod</code>","text":"<p>Hash a graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The graph to hash.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The hash of the graph.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>@staticmethod\ndef hash_graph(graph: nx.DiGraph) -&gt; int:\n    \"\"\"\n    Hash a graph.\n\n    Parameters:\n        graph: The graph to hash.\n\n    Returns:\n        The hash of the graph.\n    \"\"\"\n    adj_matrix = nx.adjacency_matrix(graph)\n    return hash(\n        (\n            tuple(adj_matrix.data),\n            tuple(adj_matrix.indices),\n            tuple(adj_matrix.indptr),\n        )\n    )\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.get_ate","title":"<code>get_ate(graph=None)</code>","text":"<p>Calculate the average treatment effect (ATE) of <code>self._treatment</code> on <code>self._outcome</code> given <code>graph</code>. If graph is not provided, <code>self._graph</code> is used.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Optional[DiGraph]</code> <p>The graph to use for the calculation.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The ATE.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def get_ate(\n    self,\n    graph: Optional[nx.DiGraph] = None,\n) -&gt; float:\n    \"\"\"\n    Calculate the average treatment effect (ATE) of `self._treatment` on `self._outcome` given `graph`.\n    If graph is not provided, `self._graph` is used.\n\n    Parameters:\n        graph: The graph to use for the calculation.\n\n    Returns:\n        The ATE.\n    \"\"\"\n\n    if graph is None:\n        graph = self._graph\n    graph_hash = ECCS.hash_graph(graph)\n    if graph_hash not in self._ate_cache:\n        self._ate_cache[graph_hash] = self.ate_calculator.get_ate_and_confidence(\n            self.data, treatment=self._treatment, outcome=self._outcome, graph=graph\n        )[\"ATE\"]\n    return self._ate_cache[graph_hash]\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.suggest","title":"<code>suggest(method, budget=None, max_results=None)</code>","text":"<p>Suggest a modification to the graph that yields a maximally different ATE, compared to the current ATE. The modification should not edit edges that are currently fixed or banned. The method used for suggestion is specified by <code>method</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The method to use for suggestion. Must be in ECCS.EDGE_SUGGESTION_METHODS.</p> required <code>budget</code> <code>Optional[int]</code> <p>The budget for finding a suggestion. Not all methods use this.</p> <code>None</code> <code>max_results</code> <code>int</code> <p>The maximum number of edits to return. The rest, if any, may be cached. If None, all suggested edits are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A tuple containing a list of the suggested edge edit(s), the resulting ATE and,</p> <code>float</code> <p>if the underlying algorithm was invoked anew, the total number of edits it produced.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>method</code> is not in ECCS.EDGE_SUGGESTION_METHODS.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def suggest(\n    self, method: str, budget: Optional[int] = None, max_results: int = None\n) -&gt; tuple[list[EdgeEdit], float, int]:\n    \"\"\"\n    Suggest a modification to the graph that yields a maximally different ATE,\n    compared to the current ATE. The modification should not edit edges that are\n    currently fixed or banned. The method used for suggestion is specified by `method`.\n\n    Parameters:\n        method: The method to use for suggestion. Must be in ECCS.EDGE_SUGGESTION_METHODS.\n        budget: The budget for finding a suggestion. Not all methods use this.\n        max_results: The maximum number of edits to return. The rest, if any, may be cached.\n            If None, all suggested edits are returned.\n\n    Returns:\n      A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n      if the underlying algorithm was invoked anew, the total number of edits it produced.\n\n    Raises:\n        ValueError: If `method` is not in ECCS.EDGE_SUGGESTION_METHODS.\n    \"\"\"\n\n    if method not in ECCS.EDGE_SUGGESTION_METHODS:\n        raise ValueError(f\"Invalid method: {method}\")\n\n    if method == \"best_single_edge_change\":\n        return self.suggest_best_single_edge_change()\n    elif method == \"best_single_adjustment_set_change\":\n        return self.suggest_best_single_adjustment_set_change(\n            max_results=max_results, use_optimized=False\n        )\n    elif method == \"best_single_adjustment_set_change_opt\":\n        return self.suggest_best_single_adjustment_set_change(\n            max_results=max_results, use_optimized=True\n        )\n    elif method == \"random_single_edge_change\":\n        return self.suggest_random_single_edge_change()\n    elif method == \"astar_single_edge_change\":\n        return self.suggest_best_single_edge_change_heuristic(\n            budget, max_results=max_results\n        )\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS._edit_and_get_ate","title":"<code>_edit_and_get_ate(edits)</code>","text":"<p>Edit a copy of the current self.graph according to <code>edits</code> and evaluate the ATE. Does not modify self.graph.</p> <p>Parameters:</p> Name Type Description Default <code>edits</code> <code>list[EdgeEdit]</code> <p>A list of edits to be made to the graph.</p> required <p>Returns:</p> Type Description <code>Optional[float]</code> <p>The ATE, or None if the graph is not acceptable.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def _edit_and_get_ate(self, edits: list[EdgeEdit]) -&gt; Optional[float]:\n    \"\"\"\n    Edit a copy of the current self.graph according to `edits` and evaluate the ATE.\n    Does not modify self.graph.\n\n    Parameters:\n        edits: A list of edits to be made to the graph.\n\n    Returns:\n        The ATE, or None if the graph is not acceptable.\n    \"\"\"\n\n    graph = self._graph.copy()\n\n    # Edit graph\n    for src, dst, edit_type in edits:\n        print(\"Applying edit: \", src, dst, edit_type)\n        if edit_type == EdgeEditType.ADD:\n            if not graph.has_edge(src, dst):\n                graph.add_edge(src, dst)\n        elif edit_type == EdgeEditType.REMOVE:\n            if graph.has_edge(src, dst):\n                graph.remove_edge(src, dst)\n        elif edit_type == EdgeEditType.FLIP:\n            if graph.has_edge(src, dst):\n                graph.remove_edge(src, dst)\n            if not graph.has_edge(dst, src):\n                graph.add_edge(dst, src)\n\n    print(\"Applied edits successfully\")\n\n    # Compute the ATE if the graph is acceptable\n    if self._is_acceptable(graph):\n        print(\"Graph is acceptable after edits: \", edits)\n        ate = self.get_ate(graph)\n        print(\"Got back ATE: \", ate)\n        return ate\n\n    print(\"Graph is not acceptable after edits: \", edits)\n    return None\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS._edit_and_draw","title":"<code>_edit_and_draw(edits)</code>","text":"<p>Edit a copy of the current self.graph according to <code>edits</code> and draw the graph. Parameters:     edits: A list of edits to be made to the graph.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>A base64-encoded string representation of the graph, or None if the graph is not acceptable.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def _edit_and_draw(self, edits: list[EdgeEdit]) -&gt; Optional[str]:\n    \"\"\"\n    Edit a copy of the current self.graph according to `edits` and draw the graph.\n    Parameters:\n        edits: A list of edits to be made to the graph.\n\n    Returns:\n        A base64-encoded string representation of the graph, or None if the graph is not acceptable.\n    \"\"\"\n\n    graph = self._graph.copy()\n    edge_decisions_matrix = self._edge_states.copy()\n\n    # Edit graph\n    for src, dst, edit_type in edits:\n        if edit_type == EdgeEditType.ADD:\n            graph.add_edge(src, dst)\n            edge_decisions_matrix.mark_edge(src, dst, EdgeState.SUGGESTED)\n        elif edit_type == EdgeEditType.REMOVE:\n            graph.remove_edge(src, dst)\n            edge_decisions_matrix.mark_edge(src, dst, EdgeState.ABSENT)\n        elif edit_type == EdgeEditType.FLIP:\n            graph.remove_edge(src, dst)\n            edge_decisions_matrix.mark_edge(src, dst, EdgeState.ABSENT)\n            graph.add_edge(dst, src)\n            edge_decisions_matrix.mark_edge(dst, src, EdgeState.SUGGESTED)\n\n    # Draw the graph if the graph is acceptable\n    if not self._is_acceptable(graph):\n        return None\n\n    return GraphRenderer.draw_graph(graph, edge_decisions_matrix)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.suggest_best_single_edge_change","title":"<code>suggest_best_single_edge_change()</code>","text":"<p>Suggest the best_single_edge_change that maximally changes the ATE.</p> <p>Returns:</p> Type Description <code>Tuple[list[EdgeEdit], float, int]</code> <p>A tuple containing a list of the suggested edge edit(s), the resulting ATE and, if the underlying algorithm was invoked anew, the total number of edits it produced.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def suggest_best_single_edge_change(\n    self,\n) -&gt; Tuple[list[EdgeEdit], float, int]:\n    \"\"\"\n    Suggest the best_single_edge_change that maximally changes the ATE.\n\n    Returns:\n        A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n            if the underlying algorithm was invoked anew, the total number of edits it produced.\n    \"\"\"\n    base_ate = self.get_ate()\n    furthest_ate = base_ate\n    best_ate_diff = 0\n    best_edits = []\n\n    def maybe_update_best(ate, edits):\n        nonlocal best_ate_diff\n        nonlocal furthest_ate\n        nonlocal best_edits\n\n        if ate is None:\n            return\n        ate_diff = abs(ate - base_ate)\n        if ate_diff &gt; best_ate_diff:\n            best_ate_diff = ate_diff\n            furthest_ate = ate\n            best_edits = edits\n\n    pairs = list(combinations(range(self._num_vars), 2))\n\n    # Iterate over all unordered pairs of variables and compute ates\n    for i, j in pairs:\n\n        # Extract edge endpoints and if none of the two are in the graph, skip\n        e1 = self._data.columns[i]\n        e2 = self._data.columns[j]\n\n        # Extract edge states\n        f_state = self.get_edge_state(e1, e2)\n        r_state = self.get_edge_state(e2, e1)\n\n        # Apply the change and evaluate the ATE\n        if f_state == EdgeState.ABSENT and (\n            r_state == EdgeState.ABSENT or r_state == EdgeState.BANNED\n        ):\n            # Try adding in the \"forward\" direction\n            ate = self._edit_and_get_ate([EdgeEdit(e1, e2, EdgeEditType.ADD)])\n            maybe_update_best(ate, [EdgeEdit(e1, e2, EdgeEditType.ADD)])\n        if r_state == EdgeState.ABSENT and (\n            f_state == EdgeState.ABSENT or f_state == EdgeState.BANNED\n        ):\n            # Try adding in the \"reverse\" direction\n            ate = self._edit_and_get_ate([EdgeEdit(e2, e1, EdgeEditType.ADD)])\n            maybe_update_best(ate, [EdgeEdit(e2, e1, EdgeEditType.ADD)])\n        if f_state == EdgeState.PRESENT:\n            # Try removing the edge\n            ate = self._edit_and_get_ate([EdgeEdit(e1, e2, EdgeEditType.REMOVE)])\n            maybe_update_best(ate, [EdgeEdit(e1, e2, EdgeEditType.REMOVE)])\n            if r_state == EdgeState.ABSENT:  # As opposed to banned\n                # Try flipping the edge\n                ate = self._edit_and_get_ate([EdgeEdit(e1, e2, EdgeEditType.FLIP)])\n                maybe_update_best(ate, [EdgeEdit(e1, e2, EdgeEditType.FLIP)])\n        if r_state == EdgeState.PRESENT:\n            # Try removing the edge\n            ate = self._edit_and_get_ate([EdgeEdit(e2, e1, EdgeEditType.REMOVE)])\n            maybe_update_best(ate, [EdgeEdit(e2, e1, EdgeEditType.REMOVE)])\n            if f_state == EdgeState.ABSENT:  # As opposed to banned\n                # Try flipping the edge\n                ate = self._edit_and_get_ate([EdgeEdit(e2, e1, EdgeEditType.FLIP)])\n                maybe_update_best(ate, [EdgeEdit(e2, e1, EdgeEditType.FLIP)])\n\n    return (best_edits, furthest_ate, 1)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS._pop_n","title":"<code>_pop_n(l, n)</code>  <code>staticmethod</code>","text":"<p>Pop <code>n</code> elements from the start of list <code>l</code> and return them as a list.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>list[Any]</code> <p>The list to pop from.</p> required <code>n</code> <code>int</code> <p>The number of elements to pop.</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>The popped elements.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>@staticmethod\ndef _pop_n(l: list[Any], n: int) -&gt; list[Any]:\n    \"\"\"\n    Pop `n` elements from the start of list `l` and return them as a list.\n\n    Parameters:\n        l: The list to pop from.\n        n: The number of elements to pop.\n\n    Returns:\n        The popped elements.\n    \"\"\"\n    elements = l[:n]\n    l[:] = l[n:]\n    return elements\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.suggest_best_single_edge_change_heuristic","title":"<code>suggest_best_single_edge_change_heuristic(budget=None, max_results=None)</code>","text":"<p>Suggest the best single edge change based on A star</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>Optional[int]</code> <p>The budget for the search.</p> <code>None</code> <code>max_results</code> <code>int</code> <p>The maximum number of edits to return. The rest, if any, are cached. If None, all suggested edits are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[list[EdgeEdit], float, int]</code> <p>A tuple containing a list of the suggested edge edit(s), the resulting ATE and, if the underlying algorithm was invoked anew, the total number of edits it produced.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def suggest_best_single_edge_change_heuristic(\n    self, budget: Optional[int] = None, max_results: int = None\n) -&gt; Tuple[list[EdgeEdit], float, int]:\n    \"\"\"\n    Suggest the best single edge change based on A star\n\n    Parameters:\n        budget: The budget for the search.\n        max_results: The maximum number of edits to return. The rest, if any, are cached.\n            If None, all suggested edits are returned.\n\n    Returns:\n        A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n            if the underlying algorithm was invoked anew, the total number of edits it produced.\n    \"\"\"\n    if len(self._cached_edit_options) &gt; 0:\n        edits = ECCS._pop_n(self._cached_edit_options, max_results)\n        return (edits, self._edit_and_get_ate(edits), 0)\n    a_star = AStarSearch(\n        self._graph,\n        self._treatment,\n        self._outcome,\n        self._data,\n        self._edge_states,\n        computational_budget=budget,\n    )\n    edits = a_star.astar()\n    self._cached_edit_options = edits[: self.A_STAR_NUM_SUGGESTIONS_PER_INVOCATION]\n    edits = ECCS._pop_n(self._cached_edit_options, max_results)\n    res = (\n        edits,\n        self._edit_and_get_ate(edits),\n        self.A_STAR_NUM_SUGGESTIONS_PER_INVOCATION,\n    )\n\n    # return ([edit], self._edit_and_get_ate([edit]), True) # TODO: FIXME\n    return res\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS._find_adjustment_set","title":"<code>_find_adjustment_set(graph, treatment, outcome)</code>  <code>staticmethod</code>","text":"<p>Find an adjustment set between the treatment and outcome variables in the graph. We achieve this by only leaving backdoor paths in the graph, by temporarily removing all edges that are directed out from the treatment variable.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The graph to search.</p> required <code>treatment</code> <code>str</code> <p>The treatment variable.</p> required <code>outcome</code> <code>str</code> <p>The outcome variable.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The adjustment set, or None if no adjustment set exists.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>@staticmethod\ndef _find_adjustment_set(\n    graph: nx.DiGraph,\n    treatment: str,\n    outcome: str,\n) -&gt; list[str]:\n    \"\"\"\n    Find an adjustment set between the treatment and outcome variables in the graph.\n    We achieve this by only leaving backdoor paths in the graph, by temporarily removing\n    all edges that are directed out from the treatment variable.\n\n    Parameters:\n        graph: The graph to search.\n        treatment: The treatment variable.\n        outcome: The outcome variable.\n\n    Returns:\n        The adjustment set, or None if no adjustment set exists.\n    \"\"\"\n    temp_removed_edges = list(graph.out_edges(treatment))\n    for edge in temp_removed_edges:\n        graph.remove_edge(edge[0], edge[1])\n    adjset = nx.algorithms.find_minimal_d_separator(graph, treatment, outcome)\n    for edge in temp_removed_edges:\n        graph.add_edge(edge[0], edge[1])\n    return adjset\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.suggest_best_single_adjustment_set_change","title":"<code>suggest_best_single_adjustment_set_change(max_results=None, use_optimized=True)</code>","text":"<p>Suggest the best_single_adjustment_set_changes that maximally changes the ATE.</p> <p>Parameters:</p> Name Type Description Default <code>max_results</code> <code>int</code> <p>The maximum number of edits to return. The rest, if any, are cached. If None, all suggested edits are returned.</p> <code>None</code> <code>use_optimized</code> <code>bool</code> <p>Whether to use the optimized version of the algorithm.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[list[EdgeEdit], float, int]</code> <p>A tuple containing a list of the suggested edge edit(s), the resulting ATE and, if the underlying algorithm was invoked anew, the total number of edits it produced.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def suggest_best_single_adjustment_set_change(\n    self, max_results: int = None, use_optimized: bool = True\n) -&gt; Tuple[list[EdgeEdit], float, int]:\n    \"\"\"\n    Suggest the best_single_adjustment_set_changes that maximally changes the ATE.\n\n    Parameters:\n        max_results: The maximum number of edits to return. The rest, if any, are cached.\n            If None, all suggested edits are returned.\n        use_optimized: Whether to use the optimized version of the algorithm.\n\n    Returns:\n        A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n            if the underlying algorithm was invoked anew, the total number of edits it produced.\n    \"\"\"\n    print(\"Computing and suggesting best single adjustment set change\")\n    print(\n        f\"The current cache size is {len(self._cached_edit_options)} and the acceptance test returns {self._cached_acceptance_test}\"\n    )\n\n    if len(self._cached_edit_options) &gt; 0 and self._cached_acceptance_test():\n        print(\n            \"Serving previous edge suggestion(s) based on best single adjustment set change\"\n        )\n        edits = ECCS._pop_n(self._cached_edit_options, max_results)\n        self._cached_acceptance_test = self._check_if_edits_were_accepted(edits)\n        return (edits, self._cached_furthest_ate, 0)\n\n    ranking = self.get_adj_set_changes_ranking(use_optimized=use_optimized, k=1)\n\n    print(\"Done evaluating options\")\n    if len(ranking) == 0:\n        return ([], self.get_ate(), 0)\n\n    _, best_edits, furthest_ate, _ = ranking[0]\n    num_best_edits = len(best_edits)\n\n    if num_best_edits == 0:\n        return ([], furthest_ate, 0)\n    elif (max_results is None) or (\n        num_best_edits &lt;= max_results\n    ):  # No need to cache edits\n        self._cached_furthest_ate = furthest_ate\n        self._cached_edit_options = []\n        self._cached_acceptance_test = None\n        return (best_edits, furthest_ate, num_best_edits)\n    else:  # Must cache some edits\n        self._cached_furthest_ate = furthest_ate\n        self._cached_edit_options = best_edits\n        edits_to_return = ECCS._pop_n(self._cached_edit_options, max_results)\n        self._cached_acceptance_test = self._check_if_edits_were_accepted(\n            edits_to_return\n        )\n        return (edits_to_return, furthest_ate, num_best_edits)\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.get_adj_set_changes_ranking","title":"<code>get_adj_set_changes_ranking(use_optimized=True, k=None, min_ate_ratio=None)</code>","text":"<p>Get a ranking of single-variable adjustment set changes, based on their impact on the ATE. Can filter by number of variables to return (<code>k</code>) and/or by the minimum relative change in ATE.</p> <p>Parameters:</p> Name Type Description Default <code>use_optimized</code> <code>bool</code> <p>Whether to use the optimized version of the algorithm.</p> <code>True</code> <code>k</code> <code>Optional[int]</code> <p>The maximum number of changes to return. If None, all are returned.</p> <code>None</code> <code>min_ate_ratio</code> <code>Optional[float]</code> <p>The minimum relative change in ATE to return. If None, all are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[str, list[EdgeEdit], float]]</code> <p>A list of tuples, each containing the variable that was changed, the corresponding edge edit(s), and the resulting ATE.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def get_adj_set_changes_ranking(\n    self,\n    use_optimized: bool = True,\n    k: Optional[int] = None,\n    min_ate_ratio: Optional[float] = None,\n) -&gt; list[tuple[str, list[EdgeEdit], float]]:\n    \"\"\"\n    Get a ranking of single-variable adjustment set changes, based on their\n    impact on the ATE. Can filter by number of variables to return (`k`) and/or\n    by the minimum relative change in ATE.\n\n    Parameters:\n        use_optimized: Whether to use the optimized version of the algorithm.\n        k: The maximum number of changes to return. If None, all are returned.\n        min_ate_ratio: The minimum relative change in ATE to return. If None, all are returned.\n\n    Returns:\n        A list of tuples, each containing the variable that was changed, the corresponding edge edit(s),\n            and the resulting ATE.\n    \"\"\"\n    base_ate = self.get_ate()\n\n    ranking = []\n    # Each element has (variable, edits, ate, ate_ratio)\n\n    def maybe_update_ranking(v, edits, ate):\n        nonlocal ranking\n\n        # If the ate couldn't be computed, return\n        if ate is None:\n            return\n\n        # If the achieved ate ratio is below cutoff, return\n        ate_ratio = abs((ate - base_ate) / base_ate)\n        if (min_ate_ratio is not None) and (ate_ratio &lt; min_ate_ratio):\n            return\n\n        # If the ranking is full and the achieved ate ratio is below the\n        # worst in the ranking, return\n        if (\n            (k is not None)\n            and (len(ranking) == k)\n            and (ate_ratio &lt;= ranking[-1][3])\n        ):\n            return\n\n        # Insert the new element in the right position in the ranking and trim\n        # down to desired length if needed.\n        inserted = False\n        for i, (_, _, _, r) in enumerate(ranking):\n            if ate_ratio &gt; r:\n                ranking.insert(i, (v, edits, ate, ate_ratio))\n                inserted = True\n                break\n        if not inserted:\n            ranking.append((v, edits, ate, ate_ratio))\n\n        if (k is not None) and (len(ranking) &gt; k):\n            ranking.pop()\n\n    base_adj_set = ECCS._find_adjustment_set(\n        self._graph, self.treatment, self.outcome\n    )\n    print(\"Found base adjustment set: \", base_adj_set)\n    vars_not_in_adj_set = [\n        v\n        for v in self.vars\n        if v not in base_adj_set and v != self.treatment and v != self.outcome\n    ]\n\n    mapper = MapAdjSetToGraph(\n        self.graph,\n        self.treatment,\n        self.outcome,\n        self._edge_states.fixed_list,\n        self._edge_states.ban_list,\n        base_adj_set,\n    )\n\n    # Try adding each of the addable\n    for v in vars_not_in_adj_set:\n        print(f\"Trying to add {v} to the adjustment set\")\n        edits = mapper.map_addition(v, use_optimized)\n        print(\"Got back edits for addition: \", edits)\n        ate = self._edit_and_get_ate(edits)\n        maybe_update_ranking(v, edits, ate)\n\n    # Try removing each of the removable\n    for v in base_adj_set:\n        print(f\"Trying to remove {v} from the adjustment set\")\n        edits = mapper.map_removal(v, use_optimized)\n        print(\"Got back edit lists for removal: \", edits)\n        ate = self._edit_and_get_ate(edits)\n        maybe_update_ranking(v, edits, ate)\n\n    return ranking\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS._check_if_edits_were_accepted","title":"<code>_check_if_edits_were_accepted(edits)</code>","text":"<p>Given a list of edits, return a lambda that will evaluate True if those edits could be the most recent edits to have been applied to self._graph.</p> <p>Parameters:</p> Name Type Description Default <code>edits</code> <code>list[EdgeEdit]</code> <p>The edits to evaluate.</p> required <p>Returns:</p> Type Description <code>Callable[[], bool]</code> <p>A lambda that will evaluate true if the edits could be the most</p> <code>Callable[[], bool]</code> <p>recent edits to have been applied to self._graph.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def _check_if_edits_were_accepted(\n    self, edits: list[EdgeEdit]\n) -&gt; Callable[[], bool]:\n    \"\"\"\n    Given a list of edits, return a lambda that will evaluate True if those edits could be the most\n    recent edits to have been applied to self._graph.\n\n    Parameters:\n        edits: The edits to evaluate.\n\n    Returns:\n        A lambda that will evaluate true if the edits could be the most\n        recent edits to have been applied to self._graph.\n    \"\"\"\n    lambdas = []\n    for src, dst, edit_type in edits:\n        if edit_type == EdgeEditType.ADD:\n            lambdas.append(lambda: self.graph.has_edge(src, dst))\n        elif edit_type == EdgeEditType.REMOVE:\n            lambdas.append(lambda: (not self.graph.has_edge(src, dst)))\n        elif edit_type == EdgeEditType.FLIP:\n            lambdas.append(\n                lambda: (\n                    self.graph.has_edge(dst, src)\n                    and not self.graph.has_edge(src, dst)\n                )\n            )\n\n    return lambda: all([l() for l in lambdas])\n</code></pre>"},{"location":"reference/eccs/eccs/#eccs.eccs.ECCS.suggest_random_single_edge_change","title":"<code>suggest_random_single_edge_change()</code>","text":"<p>Suggest a random_single_edge_change.</p> <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A tuple containing a list of the suggested edge edit(s), the resulting ATE and,</p> <code>float</code> <p>if the underlying algorithm was invoked anew, the total number of edits it produced.</p> Source code in <code>src/eccs/eccs.py</code> <pre><code>def suggest_random_single_edge_change(\n    self,\n) -&gt; Tuple[list[EdgeEdit], float, int]:\n    \"\"\"\n    Suggest a random_single_edge_change.\n\n    Returns:\n        A tuple containing a list of the suggested edge edit(s), the resulting ATE and,\n        if the underlying algorithm was invoked anew, the total number of edits it produced.\n    \"\"\"\n\n    # Derive the set of editable edges\n    eligible_pairs = list(combinations(range(self._num_vars), 2))\n    eligible_edges = [\n        (self._data.columns[i], self._data.columns[j]) for i, j in eligible_pairs\n    ]\n    eligible_edges = [\n        (src, dst)\n        for src, dst in eligible_edges\n        if src != dst  # Don't toggle self-edges\n        and not self.is_edge_fixed(src, dst)  # Don't touch fixed edges\n        and not self.is_edge_fixed(\n            dst, src\n        )  # No point toggling if reverse is fixed.\n        and not self.is_edge_banned(src, dst)  # Don't touch banned edges\n    ]\n\n    while len(eligible_edges) &gt; 0:\n        e1, e2 = eligible_edges.pop(np.random.randint(len(eligible_edges)))\n\n        edit = ()\n        if self.get_edge_state(e1, e2) == EdgeState.ABSENT:\n            edit = EdgeEdit(e1, e2, EdgeEditType.ADD)\n        else:\n            edit = EdgeEdit(e1, e2, EdgeEditType.REMOVE)\n\n        ate = self._edit_and_get_ate([edit])\n\n        if ate == None:\n            continue\n\n        return ([edit], ate, 1)\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/","title":"EdgeStateMatrix","text":""},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeState","title":"<code>EdgeState</code>","text":"<p>Different states that a directed edge can be in.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>class EdgeState:\n    \"\"\"\n    Different states that a directed edge can be in.\n    \"\"\"\n\n    BANNED = -1  # Not in the graph and defintiely should not be.\n    ABSENT = 0  # Not in the graph but could go either way.\n    PRESENT = 1  # In the graph by the user's suggestion, but could go either way.\n    SUGGESTED = 2  # In the graph by the system's suggestion, but could go either way.\n    FIXED = 3  # In the graph and definitely should be.\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix","title":"<code>EdgeStateMatrix</code>","text":"<p>A class for managing an edge state matrix.</p> <p>An edge state matrix is square, with the entry (i,j) representing the state of the directed edge between nodes i and j.</p> <p>Self-edges are not allowed. Fixing an edge bans its inverse.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>class EdgeStateMatrix:\n    \"\"\"\n    A class for managing an edge state matrix.\n\n    An edge state matrix is square, with the entry (i,j) representing the state\n    of the directed edge between nodes i and j.\n\n    Self-edges are not allowed. Fixing an edge bans its inverse.\n    \"\"\"\n\n    def __init__(\n        self, variables: list[str], default_state: EdgeState = EdgeState.ABSENT\n    ) -&gt; None:\n        \"\"\"\n        Initialize the edge state matrix to the right dimensions and ban all self-edges.\n        The rest of the edges are set to the provided default state.\n\n        Parameters:\n            variables: The variables to initialize the edge state matrix based on.\n            default_state: The default state to set the edges to.\n        \"\"\"\n\n        n = len(variables)\n        self._variables = variables\n        self._m = np.full((n, n), default_state)\n\n        for i in range(n):\n            self._m[i, i] = EdgeState.BANNED\n\n    @property\n    def m(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns the edge state matrix.\n        \"\"\"\n        return self._m\n\n    @property\n    def n(self) -&gt; int:\n        \"\"\"\n        Returns the number of nodes.\n        \"\"\"\n        return self._m.shape[0]\n\n    def clear_and_set_from_graph(\n        self,\n        graph: nx.DiGraph,\n        state_for_edges_in_graph: EdgeState = EdgeState.PRESENT,\n        state_for_edges_not_in_graph: EdgeState = EdgeState.ABSENT,\n    ) -&gt; None:\n        \"\"\"\n        Clear the edge state matrix and then set it based on the provided graph\n        and edge states. Inverses of edges in the graph, as well as self-edges,\n        are banned.\n\n        Parameters:\n            graph: The graph to use to set the edge states.\n            state_for_edges_in_graph: The state to use for edges that are in the graph.\n            state_for_edges_not_in_graph: The state to use for edges that are not in the graph.\n        \"\"\"\n\n        self._m = np.full((self.n, self.n), state_for_edges_not_in_graph)\n        for i in range(self.n):\n            for j in range(self.n):\n                if i == j:\n                    self._m[i, j] = EdgeState.BANNED\n                elif graph.has_edge(self.name(i), self.name(j)):\n                    self._m[i, j] = state_for_edges_in_graph\n\n    def clear_and_set_from_matrix(self, m: np.ndarray) -&gt; None:\n        \"\"\"\n        Clear the edge state matrix and then set it based on the provided matrix.\n\n        Parameters:\n            m: The matrix to use to set the edge states.\n        \"\"\"\n\n        self._m = m\n\n    def idx(self, var: str) -&gt; int:\n        \"\"\"\n        Retrieve the index of a variable in the edge state matrix.\n\n        Parameters:\n            var: The name of the variable.\n\n        Returns:\n            The index of the variable in the edge state matrix.\n        \"\"\"\n        return self._variables.index(var)\n\n    def name(self, idx: int) -&gt; str:\n        \"\"\"\n        Retrieve the name of a variable in the edge state matrix.\n\n        Parameters:\n            idx: The index of the variable.\n\n        Returns:\n            The name of the variable in the edge state matrix.\n        \"\"\"\n        return self._variables[idx]\n\n    def get_edge_state(self, src: str | int, dst: str | int) -&gt; EdgeState:\n        \"\"\"\n        Get the state of a specific edge.\n\n        Parameters:\n            src: The name or index of the source variable.\n            dst: The name or index of the destination variable.\n\n        Returns:\n            The state of the edge.\n        \"\"\"\n        src_idx = self.idx(src) if type(src) == str else src\n        dst_idx = self.idx(dst) if type(dst) == str else dst\n        return self._m[src_idx][dst_idx]\n\n    def is_edge_in_state(\n        self, src: str | int, dst: str | int, state: EdgeState\n    ) -&gt; bool:\n        \"\"\"\n        Check if an edge is in a specific state.\n\n        Parameters:\n            src: The name or index of the source variable.\n            dst: The name or index of the destination variable.\n            state: The state to check for.\n\n        Returns:\n            True if the edge is in the specified state, False otherwise.\n        \"\"\"\n        src_idx = self.idx(src) if type(src) == str else src\n        dst_idx = self.idx(dst) if type(dst) == str else dst\n        return self.get_edge_state(src, dst) == state\n\n    def is_edge_fixed(self, src: str | int, dst: str | int) -&gt; bool:\n        \"\"\"\n        Check if an edge is fixed.\n\n        Parameters:\n            src: The name or index of the source variable.\n            dst: The name or index of the destination variable.\n\n        Returns:\n            True if the edge is fixed, False otherwise.\n        \"\"\"\n        return self.is_edge_in_state(src, dst, EdgeState.FIXED)\n\n    def is_edge_banned(self, src: str | int, dst: str | int) -&gt; bool:\n        \"\"\"\n        Check if an edge is banned.\n\n        Parameters:\n            src: The name or index of the source variable.\n            dst: The name or index of the destination variable.\n\n        Returns:\n            True if the edge is banned, False otherwise.\n        \"\"\"\n        return self.is_edge_in_state(src, dst, EdgeState.BANNED)\n\n    def mark_edge(self, src: str | int, dst: str | int, state: EdgeState) -&gt; None:\n        \"\"\"\n        Mark an edge as being in a specified state. Fixing an edge bans its inverse.\n\n        Parameters:\n            src: The name or index of the source variable.\n            dst: The name or index of the destination variable.\n            state: The state to mark the edge with.\n        \"\"\"\n\n        src_idx = self.idx(src) if type(src) == str else src\n        dst_idx = self.idx(dst) if type(dst) == str else dst\n\n        self._m[src_idx][dst_idx] = state\n        if state == EdgeState.FIXED:\n            self._m[dst_idx][src_idx] = EdgeState.BANNED\n\n    def _all_edges_in_state(self, state: EdgeState) -&gt; list[tuple[int, int]]:\n        \"\"\"\n        Get a list of all edges in a specific state.\n\n        Parameters:\n            state: The state to check for.\n\n        Returns:\n            A list of all edges in the specified state.\n        \"\"\"\n        rows, cols = np.asarray(self.m == state).nonzero()\n        return [(self.name(rows[i]), self.name(cols[i])) for i in range(len(rows))]\n\n    @property\n    def fixed_list(self) -&gt; list[tuple[str, str]]:\n        \"\"\"\n        Get a list of all edges that are fixed.\n\n        Returns:\n            A list of all edges that are fixed.\n        \"\"\"\n        return self._all_edges_in_state(EdgeState.FIXED)\n\n    @property\n    def ban_list(self) -&gt; list[tuple[str, str]]:\n        \"\"\"\n        Get a list of all edges that are banned.\n\n        Returns:\n            A list of all edges that are banned.\n        \"\"\"\n        return self._all_edges_in_state(EdgeState.BANNED)\n\n    # Implement a copy method\n    def copy(self) -&gt; EdgeStateMatrix:\n        \"\"\"\n        Create a copy of the edge state matrix.\n\n        Returns:\n            A copy of the edge state matrix.\n        \"\"\"\n        new_matrix = EdgeStateMatrix(self._variables)\n        new_matrix.clear_and_set_from_matrix(self._m)\n        return new_matrix\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.m","title":"<code>m: np.ndarray</code>  <code>property</code>","text":"<p>Returns the edge state matrix.</p>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.n","title":"<code>n: int</code>  <code>property</code>","text":"<p>Returns the number of nodes.</p>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.fixed_list","title":"<code>fixed_list: list[tuple[str, str]]</code>  <code>property</code>","text":"<p>Get a list of all edges that are fixed.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>A list of all edges that are fixed.</p>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.ban_list","title":"<code>ban_list: list[tuple[str, str]]</code>  <code>property</code>","text":"<p>Get a list of all edges that are banned.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>A list of all edges that are banned.</p>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.__init__","title":"<code>__init__(variables, default_state=EdgeState.ABSENT)</code>","text":"<p>Initialize the edge state matrix to the right dimensions and ban all self-edges. The rest of the edges are set to the provided default state.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>list[str]</code> <p>The variables to initialize the edge state matrix based on.</p> required <code>default_state</code> <code>EdgeState</code> <p>The default state to set the edges to.</p> <code>ABSENT</code> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def __init__(\n    self, variables: list[str], default_state: EdgeState = EdgeState.ABSENT\n) -&gt; None:\n    \"\"\"\n    Initialize the edge state matrix to the right dimensions and ban all self-edges.\n    The rest of the edges are set to the provided default state.\n\n    Parameters:\n        variables: The variables to initialize the edge state matrix based on.\n        default_state: The default state to set the edges to.\n    \"\"\"\n\n    n = len(variables)\n    self._variables = variables\n    self._m = np.full((n, n), default_state)\n\n    for i in range(n):\n        self._m[i, i] = EdgeState.BANNED\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.clear_and_set_from_graph","title":"<code>clear_and_set_from_graph(graph, state_for_edges_in_graph=EdgeState.PRESENT, state_for_edges_not_in_graph=EdgeState.ABSENT)</code>","text":"<p>Clear the edge state matrix and then set it based on the provided graph and edge states. Inverses of edges in the graph, as well as self-edges, are banned.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The graph to use to set the edge states.</p> required <code>state_for_edges_in_graph</code> <code>EdgeState</code> <p>The state to use for edges that are in the graph.</p> <code>PRESENT</code> <code>state_for_edges_not_in_graph</code> <code>EdgeState</code> <p>The state to use for edges that are not in the graph.</p> <code>ABSENT</code> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def clear_and_set_from_graph(\n    self,\n    graph: nx.DiGraph,\n    state_for_edges_in_graph: EdgeState = EdgeState.PRESENT,\n    state_for_edges_not_in_graph: EdgeState = EdgeState.ABSENT,\n) -&gt; None:\n    \"\"\"\n    Clear the edge state matrix and then set it based on the provided graph\n    and edge states. Inverses of edges in the graph, as well as self-edges,\n    are banned.\n\n    Parameters:\n        graph: The graph to use to set the edge states.\n        state_for_edges_in_graph: The state to use for edges that are in the graph.\n        state_for_edges_not_in_graph: The state to use for edges that are not in the graph.\n    \"\"\"\n\n    self._m = np.full((self.n, self.n), state_for_edges_not_in_graph)\n    for i in range(self.n):\n        for j in range(self.n):\n            if i == j:\n                self._m[i, j] = EdgeState.BANNED\n            elif graph.has_edge(self.name(i), self.name(j)):\n                self._m[i, j] = state_for_edges_in_graph\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.clear_and_set_from_matrix","title":"<code>clear_and_set_from_matrix(m)</code>","text":"<p>Clear the edge state matrix and then set it based on the provided matrix.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray</code> <p>The matrix to use to set the edge states.</p> required Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def clear_and_set_from_matrix(self, m: np.ndarray) -&gt; None:\n    \"\"\"\n    Clear the edge state matrix and then set it based on the provided matrix.\n\n    Parameters:\n        m: The matrix to use to set the edge states.\n    \"\"\"\n\n    self._m = m\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.idx","title":"<code>idx(var)</code>","text":"<p>Retrieve the index of a variable in the edge state matrix.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>The name of the variable.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the variable in the edge state matrix.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def idx(self, var: str) -&gt; int:\n    \"\"\"\n    Retrieve the index of a variable in the edge state matrix.\n\n    Parameters:\n        var: The name of the variable.\n\n    Returns:\n        The index of the variable in the edge state matrix.\n    \"\"\"\n    return self._variables.index(var)\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.name","title":"<code>name(idx)</code>","text":"<p>Retrieve the name of a variable in the edge state matrix.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the variable.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the variable in the edge state matrix.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def name(self, idx: int) -&gt; str:\n    \"\"\"\n    Retrieve the name of a variable in the edge state matrix.\n\n    Parameters:\n        idx: The index of the variable.\n\n    Returns:\n        The name of the variable in the edge state matrix.\n    \"\"\"\n    return self._variables[idx]\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.get_edge_state","title":"<code>get_edge_state(src, dst)</code>","text":"<p>Get the state of a specific edge.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str | int</code> <p>The name or index of the source variable.</p> required <code>dst</code> <code>str | int</code> <p>The name or index of the destination variable.</p> required <p>Returns:</p> Type Description <code>EdgeState</code> <p>The state of the edge.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def get_edge_state(self, src: str | int, dst: str | int) -&gt; EdgeState:\n    \"\"\"\n    Get the state of a specific edge.\n\n    Parameters:\n        src: The name or index of the source variable.\n        dst: The name or index of the destination variable.\n\n    Returns:\n        The state of the edge.\n    \"\"\"\n    src_idx = self.idx(src) if type(src) == str else src\n    dst_idx = self.idx(dst) if type(dst) == str else dst\n    return self._m[src_idx][dst_idx]\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.is_edge_in_state","title":"<code>is_edge_in_state(src, dst, state)</code>","text":"<p>Check if an edge is in a specific state.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str | int</code> <p>The name or index of the source variable.</p> required <code>dst</code> <code>str | int</code> <p>The name or index of the destination variable.</p> required <code>state</code> <code>EdgeState</code> <p>The state to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge is in the specified state, False otherwise.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def is_edge_in_state(\n    self, src: str | int, dst: str | int, state: EdgeState\n) -&gt; bool:\n    \"\"\"\n    Check if an edge is in a specific state.\n\n    Parameters:\n        src: The name or index of the source variable.\n        dst: The name or index of the destination variable.\n        state: The state to check for.\n\n    Returns:\n        True if the edge is in the specified state, False otherwise.\n    \"\"\"\n    src_idx = self.idx(src) if type(src) == str else src\n    dst_idx = self.idx(dst) if type(dst) == str else dst\n    return self.get_edge_state(src, dst) == state\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.is_edge_fixed","title":"<code>is_edge_fixed(src, dst)</code>","text":"<p>Check if an edge is fixed.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str | int</code> <p>The name or index of the source variable.</p> required <code>dst</code> <code>str | int</code> <p>The name or index of the destination variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge is fixed, False otherwise.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def is_edge_fixed(self, src: str | int, dst: str | int) -&gt; bool:\n    \"\"\"\n    Check if an edge is fixed.\n\n    Parameters:\n        src: The name or index of the source variable.\n        dst: The name or index of the destination variable.\n\n    Returns:\n        True if the edge is fixed, False otherwise.\n    \"\"\"\n    return self.is_edge_in_state(src, dst, EdgeState.FIXED)\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.is_edge_banned","title":"<code>is_edge_banned(src, dst)</code>","text":"<p>Check if an edge is banned.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str | int</code> <p>The name or index of the source variable.</p> required <code>dst</code> <code>str | int</code> <p>The name or index of the destination variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the edge is banned, False otherwise.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def is_edge_banned(self, src: str | int, dst: str | int) -&gt; bool:\n    \"\"\"\n    Check if an edge is banned.\n\n    Parameters:\n        src: The name or index of the source variable.\n        dst: The name or index of the destination variable.\n\n    Returns:\n        True if the edge is banned, False otherwise.\n    \"\"\"\n    return self.is_edge_in_state(src, dst, EdgeState.BANNED)\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.mark_edge","title":"<code>mark_edge(src, dst, state)</code>","text":"<p>Mark an edge as being in a specified state. Fixing an edge bans its inverse.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str | int</code> <p>The name or index of the source variable.</p> required <code>dst</code> <code>str | int</code> <p>The name or index of the destination variable.</p> required <code>state</code> <code>EdgeState</code> <p>The state to mark the edge with.</p> required Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def mark_edge(self, src: str | int, dst: str | int, state: EdgeState) -&gt; None:\n    \"\"\"\n    Mark an edge as being in a specified state. Fixing an edge bans its inverse.\n\n    Parameters:\n        src: The name or index of the source variable.\n        dst: The name or index of the destination variable.\n        state: The state to mark the edge with.\n    \"\"\"\n\n    src_idx = self.idx(src) if type(src) == str else src\n    dst_idx = self.idx(dst) if type(dst) == str else dst\n\n    self._m[src_idx][dst_idx] = state\n    if state == EdgeState.FIXED:\n        self._m[dst_idx][src_idx] = EdgeState.BANNED\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix._all_edges_in_state","title":"<code>_all_edges_in_state(state)</code>","text":"<p>Get a list of all edges in a specific state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EdgeState</code> <p>The state to check for.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int]]</code> <p>A list of all edges in the specified state.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def _all_edges_in_state(self, state: EdgeState) -&gt; list[tuple[int, int]]:\n    \"\"\"\n    Get a list of all edges in a specific state.\n\n    Parameters:\n        state: The state to check for.\n\n    Returns:\n        A list of all edges in the specified state.\n    \"\"\"\n    rows, cols = np.asarray(self.m == state).nonzero()\n    return [(self.name(rows[i]), self.name(cols[i])) for i in range(len(rows))]\n</code></pre>"},{"location":"reference/eccs/edge_state_matrix/#eccs.edge_state_matrix.EdgeStateMatrix.copy","title":"<code>copy()</code>","text":"<p>Create a copy of the edge state matrix.</p> <p>Returns:</p> Type Description <code>EdgeStateMatrix</code> <p>A copy of the edge state matrix.</p> Source code in <code>src/eccs/edge_state_matrix.py</code> <pre><code>def copy(self) -&gt; EdgeStateMatrix:\n    \"\"\"\n    Create a copy of the edge state matrix.\n\n    Returns:\n        A copy of the edge state matrix.\n    \"\"\"\n    new_matrix = EdgeStateMatrix(self._variables)\n    new_matrix.clear_and_set_from_matrix(self._m)\n    return new_matrix\n</code></pre>"},{"location":"reference/eccs/edges/","title":"Edges","text":""},{"location":"reference/eccs/edges/#eccs.edges.EdgeEditType","title":"<code>EdgeEditType</code>","text":"<p>Class to represent possible edit types to a directed edge.</p> Source code in <code>src/eccs/edges.py</code> <pre><code>class EdgeEditType:\n    \"\"\"\n    Class to represent possible edit types to a directed edge.\n    \"\"\"\n\n    ADD: str = \"Add\"\n    REMOVE: str = \"Remove\"\n    FLIP: str = \"Flip\"\n</code></pre>"},{"location":"reference/eccs/edges/#eccs.edges.EdgeEdit","title":"<code>EdgeEdit</code>","text":"<p>Class to represent a causal graph edit.</p> Source code in <code>src/eccs/edges.py</code> <pre><code>class EdgeEdit:\n    \"\"\"\n    Class to represent a causal graph edit.\n    \"\"\"\n\n    def __init__(self, src: str, dst: str, edit_type: EdgeEditType):\n        self.src = src\n        self.dst = dst\n        self.edit_type = edit_type\n\n    @property\n    def edge(self):\n        return (self.src, self.dst)\n\n    def __str__(self):\n        return f\"{self.edit_type} edge from {self.src} to {self.dst}\"\n\n    def __eq__(self, other):\n        return (\n            self.edit_type == other.edit_type\n            and self.src == other.src\n            and self.dst == other.dst\n        )\n\n    def __hash__(self):\n        return hash((self.src, self.dst, self.edit_type))\n\n    def __repr__(self):\n        return f\"EdgeEdit({self.src},{self.dst},{self.edit_type})\"\n\n    def to_dict(self):\n        return {\n            \"edit_type\": self.edit_type,\n            \"src\": self.src,\n            \"dst\": self.dst,\n        }\n\n    def __iter__(self):\n        return iter((self.src, self.dst, self.edit_type))\n\n    @staticmethod\n    def from_dict(d):\n        return EdgeEdit(d[\"src\"], d[\"dst\"], d[\"edit_type\"])\n\n    @staticmethod\n    def to_df(edits):\n        return pd.DataFrame(\n            [edit.to_dict() for edit in edits],\n            columns=[\"Source\", \"Destination\", \"Edit Type\"],\n        )\n</code></pre>"},{"location":"reference/eccs/graph_renderer/","title":"GraphRenderer","text":""},{"location":"reference/eccs/graph_renderer/#eccs.graph_renderer.GraphRenderer","title":"<code>GraphRenderer</code>","text":"<p>Render a digraph with appropriate margins and node tags.</p> Source code in <code>src/eccs/graph_renderer.py</code> <pre><code>class GraphRenderer:\n    \"\"\"\n    Render a digraph with appropriate margins and node tags.\n    \"\"\"\n\n    most_recent_pos: Optional[dict] = None\n    most_recent_nodeset: Optional[set[str]] = None\n\n    @classmethod\n    def draw_graph(cls, graph: nx.DiGraph, esm: EdgeStateMatrix) -&gt; str:\n        \"\"\"\n        Draw a graph with appropriate margins and node tags.\n\n        Parameters:\n            graph: The graph to be drawn.\n            esm: The edge state matrix to be used to determine\n                the color of the edges.\n\n        Returns:\n            A base64-encoded string representation of the graph.\n        \"\"\"\n        if graph.number_of_nodes() == 0:\n            return \"\"\n\n        edge_colors = [\n            EDGE_STYLES[esm.get_edge_state(src, dst)][\"color\"]\n            for src, dst in graph.edges()\n        ]\n        edge_styles = [\n            EDGE_STYLES[esm.get_edge_state(src, dst)][\"style\"]\n            for src, dst in graph.edges()\n        ]\n\n        pos = None\n        if (\n            GraphRenderer.most_recent_pos is not None\n            and GraphRenderer.most_recent_nodeset == set(graph.nodes())\n        ):\n            pos = GraphRenderer.most_recent_pos\n        else:\n            pos = nx.spring_layout(graph)\n            GraphRenderer.most_recent_pos = pos\n            GraphRenderer.most_recent_nodeset = set(graph.nodes())\n\n        nx.draw(\n            graph,\n            pos,\n            edgelist=graph.edges(),\n            with_labels=False,\n            width=2.0,\n            node_color=\"#d3d3d3\",\n            edge_color=edge_colors,\n            style=edge_styles,\n        )\n        text = nx.draw_networkx_labels(graph, pos, font_size=12)\n        for _, t in text.items():\n            t.set_rotation(30)\n\n        # Fix margins\n        x_values, y_values = zip(*pos.values())\n        x_max, x_min = max(x_values), min(x_values)\n        y_max, y_min = max(y_values), min(y_values)\n        if x_max != x_min:\n            x_margin = (x_max - x_min) * 0.3\n            plt.xlim(x_min - x_margin, x_max + x_margin)\n        if y_max != y_min:\n            y_margin = (y_max - y_min) * 0.3\n            plt.ylim(y_min - y_margin, y_max + y_margin)\n\n        buffer = BytesIO()\n        plt.savefig(buffer, format=\"png\")\n        plt.clf()\n        img_str = base64.b64encode(buffer.getvalue()).decode(\"utf-8\")\n        plt.close()\n\n        return img_str\n\n    @staticmethod\n    def save_graph(graph: nx.DiGraph, esm: EdgeStateMatrix, filename: str) -&gt; None:\n        \"\"\"\n        Save the graph to a file as a png image.\n\n        Parameters:\n            graph: The graph to be saved.\n            esm: The edge state matrix to be used to determine\n                the color of the edges.\n            filename: The name of the file to which the graph should be saved.\n        \"\"\"\n        img_str = GraphRenderer.draw_graph(graph, esm)\n        with open(filename, \"wb\") as f:\n            f.write(base64.b64decode(img_str))\n\n    @staticmethod\n    def graph_string_to_html(graph: str) -&gt; HTML:\n        \"\"\"\n        Convert the string representation of the rgaph to an HTML object\n\n        Parameters:\n            graph: The graph to be displayed.\n        \"\"\"\n        return HTML(\n            '&lt;img src=\"data:image/png;base64,{}\" style=\"max-width: 100%; height: auto;\"&gt;'.format(\n                graph\n            )\n        )\n\n    @staticmethod\n    def display_graph(graph: nx.DiGraph, esm: EdgeStateMatrix) -&gt; None:\n        \"\"\"\n        Display the graph.\n\n        Parameters:\n            graph: The graph to be displayed.\n            esm: The edge state matrix to be used to determine\n                the color of the edges.\n        \"\"\"\n        display(\n            GraphRenderer.graph_string_to_html(GraphRenderer.draw_graph(graph, esm))\n        )\n</code></pre>"},{"location":"reference/eccs/graph_renderer/#eccs.graph_renderer.GraphRenderer.draw_graph","title":"<code>draw_graph(graph, esm)</code>  <code>classmethod</code>","text":"<p>Draw a graph with appropriate margins and node tags.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The graph to be drawn.</p> required <code>esm</code> <code>EdgeStateMatrix</code> <p>The edge state matrix to be used to determine the color of the edges.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A base64-encoded string representation of the graph.</p> Source code in <code>src/eccs/graph_renderer.py</code> <pre><code>@classmethod\ndef draw_graph(cls, graph: nx.DiGraph, esm: EdgeStateMatrix) -&gt; str:\n    \"\"\"\n    Draw a graph with appropriate margins and node tags.\n\n    Parameters:\n        graph: The graph to be drawn.\n        esm: The edge state matrix to be used to determine\n            the color of the edges.\n\n    Returns:\n        A base64-encoded string representation of the graph.\n    \"\"\"\n    if graph.number_of_nodes() == 0:\n        return \"\"\n\n    edge_colors = [\n        EDGE_STYLES[esm.get_edge_state(src, dst)][\"color\"]\n        for src, dst in graph.edges()\n    ]\n    edge_styles = [\n        EDGE_STYLES[esm.get_edge_state(src, dst)][\"style\"]\n        for src, dst in graph.edges()\n    ]\n\n    pos = None\n    if (\n        GraphRenderer.most_recent_pos is not None\n        and GraphRenderer.most_recent_nodeset == set(graph.nodes())\n    ):\n        pos = GraphRenderer.most_recent_pos\n    else:\n        pos = nx.spring_layout(graph)\n        GraphRenderer.most_recent_pos = pos\n        GraphRenderer.most_recent_nodeset = set(graph.nodes())\n\n    nx.draw(\n        graph,\n        pos,\n        edgelist=graph.edges(),\n        with_labels=False,\n        width=2.0,\n        node_color=\"#d3d3d3\",\n        edge_color=edge_colors,\n        style=edge_styles,\n    )\n    text = nx.draw_networkx_labels(graph, pos, font_size=12)\n    for _, t in text.items():\n        t.set_rotation(30)\n\n    # Fix margins\n    x_values, y_values = zip(*pos.values())\n    x_max, x_min = max(x_values), min(x_values)\n    y_max, y_min = max(y_values), min(y_values)\n    if x_max != x_min:\n        x_margin = (x_max - x_min) * 0.3\n        plt.xlim(x_min - x_margin, x_max + x_margin)\n    if y_max != y_min:\n        y_margin = (y_max - y_min) * 0.3\n        plt.ylim(y_min - y_margin, y_max + y_margin)\n\n    buffer = BytesIO()\n    plt.savefig(buffer, format=\"png\")\n    plt.clf()\n    img_str = base64.b64encode(buffer.getvalue()).decode(\"utf-8\")\n    plt.close()\n\n    return img_str\n</code></pre>"},{"location":"reference/eccs/graph_renderer/#eccs.graph_renderer.GraphRenderer.save_graph","title":"<code>save_graph(graph, esm, filename)</code>  <code>staticmethod</code>","text":"<p>Save the graph to a file as a png image.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The graph to be saved.</p> required <code>esm</code> <code>EdgeStateMatrix</code> <p>The edge state matrix to be used to determine the color of the edges.</p> required <code>filename</code> <code>str</code> <p>The name of the file to which the graph should be saved.</p> required Source code in <code>src/eccs/graph_renderer.py</code> <pre><code>@staticmethod\ndef save_graph(graph: nx.DiGraph, esm: EdgeStateMatrix, filename: str) -&gt; None:\n    \"\"\"\n    Save the graph to a file as a png image.\n\n    Parameters:\n        graph: The graph to be saved.\n        esm: The edge state matrix to be used to determine\n            the color of the edges.\n        filename: The name of the file to which the graph should be saved.\n    \"\"\"\n    img_str = GraphRenderer.draw_graph(graph, esm)\n    with open(filename, \"wb\") as f:\n        f.write(base64.b64decode(img_str))\n</code></pre>"},{"location":"reference/eccs/graph_renderer/#eccs.graph_renderer.GraphRenderer.graph_string_to_html","title":"<code>graph_string_to_html(graph)</code>  <code>staticmethod</code>","text":"<p>Convert the string representation of the rgaph to an HTML object</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>str</code> <p>The graph to be displayed.</p> required Source code in <code>src/eccs/graph_renderer.py</code> <pre><code>@staticmethod\ndef graph_string_to_html(graph: str) -&gt; HTML:\n    \"\"\"\n    Convert the string representation of the rgaph to an HTML object\n\n    Parameters:\n        graph: The graph to be displayed.\n    \"\"\"\n    return HTML(\n        '&lt;img src=\"data:image/png;base64,{}\" style=\"max-width: 100%; height: auto;\"&gt;'.format(\n            graph\n        )\n    )\n</code></pre>"},{"location":"reference/eccs/graph_renderer/#eccs.graph_renderer.GraphRenderer.display_graph","title":"<code>display_graph(graph, esm)</code>  <code>staticmethod</code>","text":"<p>Display the graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The graph to be displayed.</p> required <code>esm</code> <code>EdgeStateMatrix</code> <p>The edge state matrix to be used to determine the color of the edges.</p> required Source code in <code>src/eccs/graph_renderer.py</code> <pre><code>@staticmethod\ndef display_graph(graph: nx.DiGraph, esm: EdgeStateMatrix) -&gt; None:\n    \"\"\"\n    Display the graph.\n\n    Parameters:\n        graph: The graph to be displayed.\n        esm: The edge state matrix to be used to determine\n            the color of the edges.\n    \"\"\"\n    display(\n        GraphRenderer.graph_string_to_html(GraphRenderer.draw_graph(graph, esm))\n    )\n</code></pre>"},{"location":"reference/eccs/heuristic_search/","title":"HeuristicSearch","text":""},{"location":"reference/eccs/heuristic_search/#eccs.heuristic_search.AStarSearch","title":"<code>AStarSearch</code>","text":"Source code in <code>src/eccs/heuristic_search.py</code> <pre><code>class AStarSearch:\n    def __init__(\n        self,\n        init_graph: nx.DiGraph,\n        treatment: str,\n        outcome: str,\n        data: pd.DataFrame,\n        edge_states: Optional[EdgeStateMatrix] = None,\n        gamma_1: float = 2,\n        gamma_2: float = 0.5,\n        p_value_threshold: float = 0.5,\n        std_err_threshold: float = -0.01,\n        computational_budget: int = DEFAULT_BUDGET,\n    ):\n        if computational_budget is None or computational_budget &lt; 0:\n            computational_budget = DEFAULT_BUDGET\n\n        # n is the number of causal variables\n        # m is the number of edges in the initial graph\n        print(\"Initializing A star\")\n        self.m = len(init_graph.edges())\n        self.n = len(init_graph.nodes())\n        self.init_graph = init_graph\n        for (\n            n\n        ) in (\n            self.init_graph.nodes\n        ):  # This is some hacky code to make it work with graph hashing\n            self.init_graph.nodes[n][\"label\"] = self.init_graph.nodes[n][\"var_name\"]\n        self.treatment = treatment\n        self.outcome = outcome\n        self.data = data\n        self.gamma_1 = gamma_1\n        self.gamma_2 = gamma_2\n        self.p_value_threshold = p_value_threshold\n        self.std_err_threshold = std_err_threshold\n        self.ate_calculator = ATECalculator()\n        if edge_states is None:  # backwards compatibility\n            self.edge_states = EdgeStateMatrix(list(self.data.columns))\n        else:\n            self.edge_states = edge_states\n\n        # graph id -&gt; (pred graph id, (start causal variable, end causal variable, boolean addition or deletion))\n        # TODO: make this code look nicer with edge types (low priority)\n        # True is addition False is deletion\n        self._predecessors = {}\n        self._ATE_cache = {}  # causal graph id -&gt; ATE info\n        self._visited = set()\n        self._hashtag_to_id = {}  # This notes that something is hashed\n        self._id_to_graph = {}\n        self._cur_next_id = 0\n        self._computational_budget = computational_budget\n        self._f_score = {}\n        self._g_score = {}\n        self._lookahead_threshold = 3\n\n        init_ATE_info = self._get_ATE_info(0, init_graph)\n        assert 0 in self._ATE_cache\n        self.ATE_init = init_ATE_info[\"ATE\"]\n        self._init_potential = self._get_potential(0, init_graph)\n        print(\"Initialization finished\")\n\n    def _get_ATE_info(self, id: int, graph: nx.DiGraph):\n        try:\n            return self._ATE_cache[id]\n        except KeyError:\n            try:\n                ate = self.ate_calculator.get_ate_and_confidence(\n                    data=self.data,\n                    treatment=self.treatment,\n                    outcome=self.outcome,\n                    graph=graph,\n                    calculate_p_value=True,\n                    calculate_std_error=False, ## FIXME: Turned off for now\n                    get_estimand=False,\n                    print_timing_info=False,\n                )\n                self._ATE_cache[id] = ate\n            except ValueError:  # Returned by handler of nx.exception.NodeNotFound\n                # Special case of treatment and outcome being not connected\n                ate = {\"ATE\": 0, \"P-value\": 0, \"Standard Error\": 0}\n                self._ATE_cache[id] = ate\n            return ate\n\n    def _get_potential(self, id: int, graph: nx.DiGraph):\n        \"\"\"\n        v is a (id: int, corresponding causal graph: nx.DiGraph)\n        Phi(v) = |ATE_v - ATE_init| - gamma_1 * regression error + gamma_2 * other heuristic\n        For now, use |number of edges in v - n| as the \"other heuristic\"\n        Could plug in other forms of assessment in the literatures here\n        \"\"\"\n        # {\"ATE\": float, \"P-value\": float, \"Standard Error\": float, \"Estimand\": ?}\n        # TODO: what is the type of Estimand\n        # TODO: implement caching for ATE information\n        ATE_info = self._get_ATE_info(id, graph)\n        # The math.inf stops graphs where treatment and outcome are not direct connected\n\n        \"\"\"\n        stderr = 0\n        if ATE_info[\"Standard Error\"] == 0:\n            stderr = 1\n        else:\n            try:\n                stderr = ATE_info[\"Standard Error\"][0]\n            except IndexError:\n                stderr = ATE_info[\"Standard Error\"]\n        \"\"\"\n\n        return (\n            ATE_info[\"ATE\"]\n            #- self.gamma_1 * stderr\n            + ATE_info[\"P-value\"]\n            + 0.01 * abs(len(graph.edges()) - self.m * 2)\n        )  # TODO: 2 is a guess of average degree\n\n    def _explore_neighbor(\n        self,\n        current_node_id: int,\n        graph: nx.DiGraph,\n        n1: int,\n        n2: int,\n        frontier: List[Any],\n        n_lookahead: int,\n        is_add: bool,\n    ) -&gt; Optional[int]:\n        # the type of nx node is int unless DiGraph.nodes() was called with data options\n        # returns the id of the new neighbor or None if we don't explore\n\n        if (\n            not is_add and len(graph.edges()) &lt;= self.n\n        ):  # Only explore completely connected graphs\n            return (None, None)\n        if (\n            is_add and len(graph.edges()) &gt;= self.n * self.n // 2\n        ):  # Skip overly connected graphs too\n            return (None, None)\n\n        if is_add:\n            graph.add_edge(n1, n2)\n        else:\n            graph.remove_edge(n1, n2)\n        hashtag = dihash.hash_graph(graph, hash_nodes=False, apply_quotient=False)\n        if (\n            hashtag not in self._hashtag_to_id\n        ):  # not seen yet, mark it as seen by storing hash\n            self._hashtag_to_id[hashtag] = self._cur_next_id\n            self._cur_next_id += 1\n\n        id = self._hashtag_to_id[hashtag]\n        ATE_info = self._get_ATE_info(id, graph)\n\n        # if ATE_info[\"P-value\"] &lt; self.p_value_threshold:\n        #if ATE_info[\"Standard Error\"] &gt; self.std_err_threshold:\n        if ATE_info[\"ATE\"] &lt;= 0.01:\n            # self._visited.add(id)  # discard\n            if id not in self._id_to_graph:\n                new_graph = graph.copy()\n                self._id_to_graph[id] = new_graph\n            if n_lookahead &lt; self._lookahead_threshold:\n                f_score = self._f_score.get(\n                    id, self._g_score[current_node_id] - self._get_potential(id, graph)\n                )\n                if id not in self._f_score:\n                    self._f_score[id] = f_score\n                if id not in self._g_score:\n                    self._g_score[id] = self._g_score[current_node_id]\n                heapq.heappush(frontier, (f_score, id, n_lookahead + 1))\n\n        result = None\n        if id not in self._visited:\n            # explore (but not commit to the path, so we don't set the precedessor here)\n            if id not in self._id_to_graph:  # store the result of this exploration\n                new_graph = graph.copy()\n                self._id_to_graph[id] = new_graph\n            result = id\n\n        # Revert the change on this graph before finish exploring\n        if is_add:\n            graph.remove_edge(n1, n2)\n        else:\n            graph.add_edge(n1, n2)\n        return (result, (n1, n2, is_add))\n\n    def _get_neighbors(\n        self, current_node_id: int, frontier: List[Any], n_lookahead: int\n    ) -&gt; List[Tuple[int, Tuple[int, int, bool]]]:\n        # Returns list of neighbors\n        graph: nx.DiGraph = self._id_to_graph[current_node_id]\n        results = []\n        for n1 in list(graph.nodes):\n            for n2 in list(graph.nodes):\n                if n2 == n1:\n                    continue  # skip self-loops\n                neighbor_res = None\n                if graph.has_edge(n1, n2) and not self.edge_states.is_edge_fixed(\n                    n1, n2\n                ):\n                    neighbor_res = self._explore_neighbor(\n                        current_node_id,\n                        graph,\n                        n1,\n                        n2,\n                        frontier,\n                        n_lookahead,\n                        is_add=False,\n                    )\n                elif n2 in nx.ancestors(graph, n1):\n                    continue  # Adding this edge his creates a cycle\n                elif not graph.has_edge(n1, n2) and not self.edge_states.is_edge_banned(n1, n2):\n                    neighbor_res = self._explore_neighbor(\n                        current_node_id,\n                        graph,\n                        n1,\n                        n2,\n                        frontier,\n                        n_lookahead,\n                        is_add=True,\n                    )\n                if neighbor_res is not None and len(neighbor_res) &gt; 0 and neighbor_res[0] is not None:\n                    results.append(neighbor_res)\n\n        return results\n\n    def heuristic(self, predecessor, node):\n        # predecessor was taken from the frontier pq, node is the candidate for expansion\n        # the weight of an edge (v1, v2) in the A* graph is Phi(v1) - Phi(v2) since we want to\n        # go towards the maximal Phi causal graph.\n        # A* heuristic f(n) = g(n) + h(n). g(n) is the cost of this explored path, h(n) is a heuristical\n        # estimate of the cost from here to the destination. To be admissible, h(n) cannot overestimate the true\n        # value. Therefore, we use -Phi(v2) as an estimate for now.\n        # g(n) = Phi(init) - Phi(current frontier of the path)\n        return (\n            self._init_potential\n            - self._get_potential(predecessor)\n            - self._get_potential(node)\n        )\n\n    def astar(self, k: int = 100):\n        # Side effect: prints the top 10 result\n        # Returns the most frequently seen edge flips in sorted order\n        frontier = [\n            (0, self._cur_next_id, 0)\n        ]  # this is the pq (f(v), v), only store the ID\n        self._cur_next_id += 1\n\n        start_hash = dihash.hash_graph(\n            self.init_graph, hash_nodes=False, apply_quotient=False\n        )\n        # self._visited.add(0)  # store actual graph here\n        self._hashtag_to_id[start_hash] = 0\n        self._id_to_graph[0] = self.init_graph\n        # starting node always has id 0\n        self._f_score[0] = -self._get_potential(0, self.init_graph)\n        # g_score[0] = self._init_potential + f_score[0]\n        self._g_score[0] = self._f_score[0]\n\n        top_k_candidates = []\n\n        while frontier:\n            _, current_node_id, n_lookahead = heapq.heappop(frontier)\n            if current_node_id in self._visited:\n                continue\n            heapq.heappush(\n                top_k_candidates,\n                (\n                    self._get_potential(\n                        current_node_id, self._id_to_graph[current_node_id]\n                    ),\n                    current_node_id,\n                ),\n            )\n            if len(top_k_candidates) &gt; k:\n                heapq.heappop(top_k_candidates)\n            neighbors = self._get_neighbors(current_node_id, frontier, n_lookahead)\n            if self._cur_next_id &gt; self._computational_budget:\n                print(\n                    \"Out of computational budget: \",\n                    self._cur_next_id,\n                    self._computational_budget,\n                )\n                break\n            for neighbor_id, edge_type in neighbors:\n                # when expanding neighbors, just discard ones that are too low p-value\n                tentative_g_score = self._g_score[current_node_id]\n                neighbor_g_score = self._g_score.get(\n                    neighbor_id,\n                    self._init_potential\n                    - self._get_potential(neighbor_id, self._id_to_graph[neighbor_id]),\n                )\n                if tentative_g_score &lt;= neighbor_g_score:\n                    self._predecessors[neighbor_id] = (current_node_id, edge_type)\n                    self._g_score[neighbor_id] = tentative_g_score\n                    # f_score[neighbor_id] = tentative_g_score + self.heuristic(neighbor)\n                    self._f_score[neighbor_id] = (\n                        tentative_g_score\n                        - self._get_potential(\n                            neighbor_id, self._id_to_graph[neighbor_id]\n                        )\n                    )\n                    heapq.heappush(\n                        frontier, (self._f_score[neighbor_id], neighbor_id, 0)\n                    )\n\n                if self._cur_next_id &gt; self._computational_budget:\n                    print(\n                        \"Out of computational budget: \",\n                        self._cur_next_id,\n                        self._computational_budget,\n                    )\n                    break\n            self._visited.add(current_node_id)\n\n        edge_tally = {}\n\n        for p in top_k_candidates:\n            c_id = p[1]\n            initial_c_id = p[1]\n            while c_id in self._predecessors:\n                c_id, (n1, n2, _) = self._predecessors[c_id]\n                if (n1, n2) not in edge_tally:\n                    edge_tally[(n1, n2)] = (\n                        1,\n                        abs(self._ATE_cache[initial_c_id][\"ATE\"] - self.ATE_init),\n                    )\n                else:\n                    cnt = edge_tally[(n1, n2)][0] + 1\n                    total_diff = edge_tally[(n1, n2)][1] + abs(\n                        self._ATE_cache[initial_c_id][\"ATE\"] - self.ATE_init\n                    )\n                    edge_tally[(n1, n2)] = (cnt, total_diff)\n\n        num_return = 10\n        res = []\n        sorted_edges = sorted(edge_tally.items(), key=lambda x: x[1][0], reverse=True)                \n        print(\"The top 10 edges are\")\n        print(sorted_edges[:10])\n        for (edge, _) in sorted_edges:\n            src = edge[0]\n            dst = edge[1]\n            if self.edge_states.is_edge_fixed(src, dst):\n                continue\n\n            edit_type = EdgeEditType.REMOVE if self.init_graph.has_edge(src, dst) else EdgeEditType.ADD\n            res.append(EdgeEdit(src, dst, edit_type))\n            if len(res) &gt; num_return:\n                break\n\n        # Convert top edge to EdgeEdit\n        if len(sorted_edges) == 0:\n            return []\n        return res\n</code></pre>"},{"location":"reference/eccs/heuristic_search/#eccs.heuristic_search.AStarSearch._get_potential","title":"<code>_get_potential(id, graph)</code>","text":"<p>v is a (id: int, corresponding causal graph: nx.DiGraph) Phi(v) = |ATE_v - ATE_init| - gamma_1 * regression error + gamma_2 * other heuristic For now, use |number of edges in v - n| as the \"other heuristic\" Could plug in other forms of assessment in the literatures here</p> Source code in <code>src/eccs/heuristic_search.py</code> <pre><code>def _get_potential(self, id: int, graph: nx.DiGraph):\n    \"\"\"\n    v is a (id: int, corresponding causal graph: nx.DiGraph)\n    Phi(v) = |ATE_v - ATE_init| - gamma_1 * regression error + gamma_2 * other heuristic\n    For now, use |number of edges in v - n| as the \"other heuristic\"\n    Could plug in other forms of assessment in the literatures here\n    \"\"\"\n    # {\"ATE\": float, \"P-value\": float, \"Standard Error\": float, \"Estimand\": ?}\n    # TODO: what is the type of Estimand\n    # TODO: implement caching for ATE information\n    ATE_info = self._get_ATE_info(id, graph)\n    # The math.inf stops graphs where treatment and outcome are not direct connected\n\n    \"\"\"\n    stderr = 0\n    if ATE_info[\"Standard Error\"] == 0:\n        stderr = 1\n    else:\n        try:\n            stderr = ATE_info[\"Standard Error\"][0]\n        except IndexError:\n            stderr = ATE_info[\"Standard Error\"]\n    \"\"\"\n\n    return (\n        ATE_info[\"ATE\"]\n        #- self.gamma_1 * stderr\n        + ATE_info[\"P-value\"]\n        + 0.01 * abs(len(graph.edges()) - self.m * 2)\n    )  # TODO: 2 is a guess of average degree\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/","title":"MapAdjSetToGraph","text":""},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph","title":"<code>MapAdjSetToGraph</code>","text":"<p>A class for mapping adjustment set edits to causal graph edits.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>class MapAdjSetToGraph:\n    \"\"\"\n    A class for mapping adjustment set edits to causal graph edits.\n    \"\"\"\n\n    def __init__(\n        self,\n        graph: nx.DiGraph,\n        treatment: str,\n        outcome: str,\n        fix_list: list[Edge],\n        ban_list: list[Edge],\n        base_adj_set: Optional[list[str]] = None,\n    ):\n        \"\"\"\n        Initializes the class.\n\n        Parameters:\n            graph: The causal graph.\n            treatment: The treatment variable.\n            outcome: The outcome variable.\n            base_adj_set: The starting adjustment set.\n        \"\"\"\n        self.graph = graph\n        self.treatment = treatment\n        self.outcome = outcome\n        self.fix_list = fix_list\n        self.ban_list = ban_list\n        self.base_adj_set = base_adj_set\n\n    def update_fixlist(self, fix_list: list[Edge]) -&gt; None:\n        \"\"\"\n        Update the fix list.\n\n        Parameters:\n            fix_list: The new fix list.\n        \"\"\"\n        self.fix_list = fix_list\n\n    def update_banlist(self, ban_list: list[Edge]) -&gt; None:\n        \"\"\"\n        Update the ban list.\n\n        Parameters:\n            ban_list: The new ban list.\n        \"\"\"\n        self.ban_list = ban_list\n\n    def _find_directed_paths(self, src: str, dst: str) -&gt; list[Path]:\n        \"\"\"\n        Find all directed paths between two nodes in the graph.\n\n        Parameters:\n            src: The source node.\n            dst: The destination node.\n\n        Returns:\n            A list of directed paths.\n        \"\"\"\n        return list(nx.all_simple_edge_paths(self.graph, src, dst))\n\n    def _break_path_near(self, path: Path, var: str) -&gt; Optional[EdgeEdit]:\n        \"\"\"\n        Find an edge to remove that will break the path near a variable. The variable\n        has to be the first or last node in the path.\n\n        Parameters:\n            path: The path to break.\n            var: The variable to break the path near.\n\n        Returns:\n            An edge edit that will break the path near the variable.\n        \"\"\"\n        step = 1\n\n        if var == path[-1][1]:\n            step = -1\n        elif var != path[0][0]:\n            return None\n\n        for edge in path[::step]:\n            if edge not in self.fix_list:\n                return EdgeEdit(edge[0], edge[1], EdgeEditType.REMOVE)\n        return None\n\n    def _find_ordered_descendants(self, v: str) -&gt; list[str]:\n        \"\"\"\n        Find all descendants of a variable, including itself, and order them by their distance from the variable.\n\n        Parameters:\n            v: The variable.\n\n        Returns:\n            A list of descendants ordered by their distance from the variable.\n        \"\"\"\n        d = []\n        q = deque([v])\n        while len(q) &gt; 0:\n            current = q.popleft()\n            d.append(current)\n            q.extend([n for n in nx.descendants(self.graph, current) if n not in d])\n        return d\n\n    def map_addition(\n        self,\n        v: str,\n        use_optimized: bool = True,\n    ) -&gt; list[EdgeEdit]:\n        \"\"\"\n        Map an addition to the adjustment set to a list of causal graph edits.\n\n        Parameters:\n            v: The variable to add to the adjustment set.\n            use_optimized: Whether to use the optimized version of the function, developed after the ECCS paper.\n\n        Returns:\n            A list of causal graph edits that correspond to the addition of v to the adjustment set.\n        \"\"\"\n        if use_optimized:\n            return self._optimized_map_addition(v)\n        return self._unoptimized_map_addition(v)\n\n    def _optimized_map_addition(\n        self,\n        v: str,\n    ) -&gt; list[EdgeEdit]:\n        \"\"\"\n        Map an addition to the adjustment set to a list of causal graph edits. This is the version of\n        this function developed after the ECCS paper.\n\n        Parameters:\n            v: The variable to add to the adjustment set.\n\n        Returns:\n            A list of causal graph edits that correspond to the addition of v to the adjustment set.\n        \"\"\"\n\n        S = []\n        if v in nx.descendants(self.graph, self.treatment):\n            B, success = self._break_paths(self.treatment, v)\n            if not success:\n                return []\n            S.extend(B)\n        ignore = [e.edge for e in S]\n        if self._is_reachable_with_ignored_edges(self.outcome, v, ignore):\n            B, success = self._break_paths(self.outcome, v, ignore)\n            if not success:\n                return []\n            S.extend(B)\n\n        if not self.graph.has_edge(v, self.treatment):\n            S.append(EdgeEdit(v, self.treatment, EdgeEditType.ADD))\n        if not self.graph.has_edge(v, self.outcome):\n            S.append(EdgeEdit(v, self.outcome, EdgeEditType.ADD))\n        return S\n\n    def _unoptimized_map_addition(\n        self,\n        v: str,\n    ) -&gt; list[EdgeEdit]:\n        \"\"\"\n        Map an addition to the adjustment set to a list of causal graph edits. This is the version of\n        this function presented in the ECCS paper.\n\n        Parameters:\n            v: The variable to add to the adjustment set.\n\n        Returns:\n            A list of causal graph edits that correspond to the addition of v to the adjustment set.\n        \"\"\"\n\n        e = []\n        if v in nx.descendants(self.graph, self.treatment) or v in nx.descendants(\n            self.graph, self.outcome\n        ):\n            paths = self._find_directed_paths(\n                self.treatment, v\n            ) + self._find_directed_paths(v, self.outcome)\n            for p in paths:\n                edit = self._break_path_near(p, v)\n                if edit is None:\n                    return []\n                e.append(edit)\n        e.append(EdgeEdit(v, self.treatment, EdgeEditType.ADD))\n        e.append(EdgeEdit(v, self.outcome, EdgeEditType.ADD))\n        return list(set(e))\n\n    def map_removal(\n        self,\n        v: str,\n        use_optimized: bool = True,\n    ) -&gt; list[EdgeEdit]:\n        \"\"\"\n        Map a removal from the adjustment set to a list of causal graph edits.\n\n        Parameters:\n            v: The variable to remove from the adjustment set.\n            use_optimized: Whether to use the optimized version of the function, developed after the ECCS paper.\n\n        Returns:\n            A list of causal graph edits that correspond to the removal of v from the adjustment set. If the\n            returned list is empty, the removal was unsuccessful.\n        \"\"\"\n\n        if use_optimized:\n            return self._optimized_map_removal(v)\n        return self._unoptimized_map_removal(v)\n\n    def _optimized_map_removal(\n        self,\n        v: str,\n    ) -&gt; list[EdgeEdit]:\n        \"\"\"\n        Map a removal from the adjustment set to a list of causal graph edits. This is the version of\n        this function developed after the ECCS paper.\n\n        Parameters:\n            v: The variable to remove from the adjustment set.\n\n        Returns:\n            A list of causal graph edits that correspond to the removal of v from the adjustment set. If\n            the returned list is empty, the removal was unsuccessful.\n        \"\"\"\n\n        v_descendants = nx.descendants(self.graph, v)\n        t_bfs_descendants = self._BFS_descendants(self.treatment)\n        t_bfs_descendants_and_v_descendants = []\n\n        # First search among descendants that don't need path breaking.\n        for w in t_bfs_descendants:\n            if (w, v) in self.ban_list:\n                continue\n\n            if w in v_descendants:\n                t_bfs_descendants_and_v_descendants.append(w)\n                continue\n\n            return [EdgeEdit(w, v, EdgeEditType.ADD)]\n\n        # If unsuccessful, next search among descendants that need path breaking.\n        best_S = []\n        for w in t_bfs_descendants_and_v_descendants:\n            S, success = self._break_paths(v, w)\n            if not success:\n                continue\n            if not self._is_reachable_with_ignored_edges(\n                self.treatment, w, [e.edge for e in S]\n            ):\n                continue\n            S.append(EdgeEdit(w, v, EdgeEditType.ADD))\n            if len(S) &lt; len(best_S) or len(best_S) == 0:\n                best_S = S\n\n        return best_S\n\n    def _unoptimized_map_removal(\n        self,\n        v: str,\n    ) -&gt; list[EdgeEdit]:\n        \"\"\"\n        Map a removal from the adjustment set to a list of causal graph edits. This is the version of\n        this function presented in the ECCS paper.\n\n        Parameters:\n            v: The variable to remove from the adjustment set.\n\n        Returns:\n            A list of causal graph edits that correspond to the removal of v from the adjustment set. If\n            the returned list is empty, the removal was unsuccessful.\n        \"\"\"\n\n        e = []\n        if v in nx.ancestors(self.graph, self.treatment):\n            paths = self._find_directed_paths(v, self.treatment)\n            for p in paths:\n                edit = self._break_path_near(p, v)\n                if edit is None:\n                    return []\n                e.append(edit)\n\n        ord_desc = self._find_ordered_descendants(self.treatment)\n        for w in ord_desc:\n            if not (w, v) in self.ban_list:\n                if (v, w) in self.graph.edges:\n                    e.append(EdgeEdit(v, w, EdgeEditType.FLIP))\n                else:\n                    e.append(EdgeEdit(w, v, EdgeEditType.ADD))\n                return list(set(e))\n        return []\n\n    def _all_reachable_with_ignored_edges(\n        self, source: str, ignore: Optional[set[Edge]] = None, reverse: bool = False\n    ) -&gt; set[str]:\n        \"\"\"\n        Perform a breadth-first search starting from a source node, ignoring certain edges,\n        and return a list of reachable nodes.\n\n        Parameters:\n            source: The source node.\n            ignore: The edges to ignore.\n            reverse: Whether to perform the search in the reverse directed graph.\n\n        Returns:\n            A set of reachable nodes.\n        \"\"\"\n\n        queue = deque([source])\n        visited = set([source])\n\n        if reverse:\n            next_nodes = self.graph.predecessors\n            edge_is_ignored = (\n                (lambda x, y: (y, x) in ignore) if ignore else (lambda x, y: False)\n            )\n        else:\n            next_nodes = self.graph.successors\n            edge_is_ignored = (\n                (lambda x, y: (x, y) in ignore) if ignore else (lambda x, y: False)\n            )\n\n        while queue:\n            node = queue.popleft()\n            for neighbor in next_nodes(node):\n                if edge_is_ignored(node, neighbor):\n                    continue\n\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n        return visited\n\n    def _is_reachable_with_ignored_edges(\n        self, source: str, sink: str, ignore: set[Edge]\n    ) -&gt; bool:\n        \"\"\"\n        Check if a sink node is reachable from a source node, ignoring certain edges.\n\n        Parameters:\n            source: The source node.\n            sink: The sink node.\n            ignore: The edges to ignore.\n\n        Returns:\n            A boolean indicating whether the sink node is reachable from the source node.\n        \"\"\"\n\n        return sink in self._all_reachable_with_ignored_edges(source, ignore)\n\n    def _break_paths(\n        self, source: str, sink: str, ignore: Optional[set[Edge]] = None\n    ) -&gt; tuple[list[EdgeEdit], bool]:\n        \"\"\"\n        Break all directed paths between two nodes in a directed graph, ignoring any edges specified in `ignore`.\n\n        Parameters:\n            source: The source node.\n            sink: The sink node.\n            ignore: The edges to ignore.\n\n        Returns:\n            A list of causal graph edits that break all paths between the two nodes, and a boolean indicating success.\n        \"\"\"\n\n        reachable_from_source = self._all_reachable_with_ignored_edges(source, ignore)\n        sink_reachable_from = self._all_reachable_with_ignored_edges(\n            sink, ignore, reverse=True\n        )\n\n        nodes_to_keep = reachable_from_source.intersection(sink_reachable_from)\n        if len(nodes_to_keep) == 0:\n            return [], True\n\n        B = []\n        queue = deque([source])\n        visited = set([source])\n\n        while queue:\n            V = queue.popleft()\n\n            if V == sink:\n                return [], False\n\n            for W in self.graph.successors(V):\n                if W not in nodes_to_keep:\n                    continue\n                if (V, W) not in self.fix_list:\n                    B.append(EdgeEdit(V, W, EdgeEditType.REMOVE))\n                elif W not in visited:\n                    visited.add(W)\n                    queue.append(W)\n\n        return B, True\n\n    def _BFS_descendants(self, v: str) -&gt; list[str]:\n        \"\"\"\n        Return the descendants of a variable, starting with the variable itself, in breadth-first search order.\n\n        Parameters:\n            v: The variable.\n\n        Returns:\n            A list of descendants in BFS order.\n        \"\"\"\n        queue = deque([v])\n        visited = [v]\n\n        while queue:\n            node = queue.popleft()\n            for neighbor in self.graph.successors(node):\n                if neighbor not in visited:\n                    visited.append(neighbor)\n                    queue.append(neighbor)\n\n        return visited\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph.__init__","title":"<code>__init__(graph, treatment, outcome, fix_list, ban_list, base_adj_set=None)</code>","text":"<p>Initializes the class.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>DiGraph</code> <p>The causal graph.</p> required <code>treatment</code> <code>str</code> <p>The treatment variable.</p> required <code>outcome</code> <code>str</code> <p>The outcome variable.</p> required <code>base_adj_set</code> <code>Optional[list[str]]</code> <p>The starting adjustment set.</p> <code>None</code> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def __init__(\n    self,\n    graph: nx.DiGraph,\n    treatment: str,\n    outcome: str,\n    fix_list: list[Edge],\n    ban_list: list[Edge],\n    base_adj_set: Optional[list[str]] = None,\n):\n    \"\"\"\n    Initializes the class.\n\n    Parameters:\n        graph: The causal graph.\n        treatment: The treatment variable.\n        outcome: The outcome variable.\n        base_adj_set: The starting adjustment set.\n    \"\"\"\n    self.graph = graph\n    self.treatment = treatment\n    self.outcome = outcome\n    self.fix_list = fix_list\n    self.ban_list = ban_list\n    self.base_adj_set = base_adj_set\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph.update_fixlist","title":"<code>update_fixlist(fix_list)</code>","text":"<p>Update the fix list.</p> <p>Parameters:</p> Name Type Description Default <code>fix_list</code> <code>list[Edge]</code> <p>The new fix list.</p> required Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def update_fixlist(self, fix_list: list[Edge]) -&gt; None:\n    \"\"\"\n    Update the fix list.\n\n    Parameters:\n        fix_list: The new fix list.\n    \"\"\"\n    self.fix_list = fix_list\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph.update_banlist","title":"<code>update_banlist(ban_list)</code>","text":"<p>Update the ban list.</p> <p>Parameters:</p> Name Type Description Default <code>ban_list</code> <code>list[Edge]</code> <p>The new ban list.</p> required Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def update_banlist(self, ban_list: list[Edge]) -&gt; None:\n    \"\"\"\n    Update the ban list.\n\n    Parameters:\n        ban_list: The new ban list.\n    \"\"\"\n    self.ban_list = ban_list\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._find_directed_paths","title":"<code>_find_directed_paths(src, dst)</code>","text":"<p>Find all directed paths between two nodes in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The source node.</p> required <code>dst</code> <code>str</code> <p>The destination node.</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>A list of directed paths.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _find_directed_paths(self, src: str, dst: str) -&gt; list[Path]:\n    \"\"\"\n    Find all directed paths between two nodes in the graph.\n\n    Parameters:\n        src: The source node.\n        dst: The destination node.\n\n    Returns:\n        A list of directed paths.\n    \"\"\"\n    return list(nx.all_simple_edge_paths(self.graph, src, dst))\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._break_path_near","title":"<code>_break_path_near(path, var)</code>","text":"<p>Find an edge to remove that will break the path near a variable. The variable has to be the first or last node in the path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to break.</p> required <code>var</code> <code>str</code> <p>The variable to break the path near.</p> required <p>Returns:</p> Type Description <code>Optional[EdgeEdit]</code> <p>An edge edit that will break the path near the variable.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _break_path_near(self, path: Path, var: str) -&gt; Optional[EdgeEdit]:\n    \"\"\"\n    Find an edge to remove that will break the path near a variable. The variable\n    has to be the first or last node in the path.\n\n    Parameters:\n        path: The path to break.\n        var: The variable to break the path near.\n\n    Returns:\n        An edge edit that will break the path near the variable.\n    \"\"\"\n    step = 1\n\n    if var == path[-1][1]:\n        step = -1\n    elif var != path[0][0]:\n        return None\n\n    for edge in path[::step]:\n        if edge not in self.fix_list:\n            return EdgeEdit(edge[0], edge[1], EdgeEditType.REMOVE)\n    return None\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._find_ordered_descendants","title":"<code>_find_ordered_descendants(v)</code>","text":"<p>Find all descendants of a variable, including itself, and order them by their distance from the variable.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of descendants ordered by their distance from the variable.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _find_ordered_descendants(self, v: str) -&gt; list[str]:\n    \"\"\"\n    Find all descendants of a variable, including itself, and order them by their distance from the variable.\n\n    Parameters:\n        v: The variable.\n\n    Returns:\n        A list of descendants ordered by their distance from the variable.\n    \"\"\"\n    d = []\n    q = deque([v])\n    while len(q) &gt; 0:\n        current = q.popleft()\n        d.append(current)\n        q.extend([n for n in nx.descendants(self.graph, current) if n not in d])\n    return d\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph.map_addition","title":"<code>map_addition(v, use_optimized=True)</code>","text":"<p>Map an addition to the adjustment set to a list of causal graph edits.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable to add to the adjustment set.</p> required <code>use_optimized</code> <code>bool</code> <p>Whether to use the optimized version of the function, developed after the ECCS paper.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A list of causal graph edits that correspond to the addition of v to the adjustment set.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def map_addition(\n    self,\n    v: str,\n    use_optimized: bool = True,\n) -&gt; list[EdgeEdit]:\n    \"\"\"\n    Map an addition to the adjustment set to a list of causal graph edits.\n\n    Parameters:\n        v: The variable to add to the adjustment set.\n        use_optimized: Whether to use the optimized version of the function, developed after the ECCS paper.\n\n    Returns:\n        A list of causal graph edits that correspond to the addition of v to the adjustment set.\n    \"\"\"\n    if use_optimized:\n        return self._optimized_map_addition(v)\n    return self._unoptimized_map_addition(v)\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._optimized_map_addition","title":"<code>_optimized_map_addition(v)</code>","text":"<p>Map an addition to the adjustment set to a list of causal graph edits. This is the version of this function developed after the ECCS paper.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable to add to the adjustment set.</p> required <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A list of causal graph edits that correspond to the addition of v to the adjustment set.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _optimized_map_addition(\n    self,\n    v: str,\n) -&gt; list[EdgeEdit]:\n    \"\"\"\n    Map an addition to the adjustment set to a list of causal graph edits. This is the version of\n    this function developed after the ECCS paper.\n\n    Parameters:\n        v: The variable to add to the adjustment set.\n\n    Returns:\n        A list of causal graph edits that correspond to the addition of v to the adjustment set.\n    \"\"\"\n\n    S = []\n    if v in nx.descendants(self.graph, self.treatment):\n        B, success = self._break_paths(self.treatment, v)\n        if not success:\n            return []\n        S.extend(B)\n    ignore = [e.edge for e in S]\n    if self._is_reachable_with_ignored_edges(self.outcome, v, ignore):\n        B, success = self._break_paths(self.outcome, v, ignore)\n        if not success:\n            return []\n        S.extend(B)\n\n    if not self.graph.has_edge(v, self.treatment):\n        S.append(EdgeEdit(v, self.treatment, EdgeEditType.ADD))\n    if not self.graph.has_edge(v, self.outcome):\n        S.append(EdgeEdit(v, self.outcome, EdgeEditType.ADD))\n    return S\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._unoptimized_map_addition","title":"<code>_unoptimized_map_addition(v)</code>","text":"<p>Map an addition to the adjustment set to a list of causal graph edits. This is the version of this function presented in the ECCS paper.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable to add to the adjustment set.</p> required <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A list of causal graph edits that correspond to the addition of v to the adjustment set.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _unoptimized_map_addition(\n    self,\n    v: str,\n) -&gt; list[EdgeEdit]:\n    \"\"\"\n    Map an addition to the adjustment set to a list of causal graph edits. This is the version of\n    this function presented in the ECCS paper.\n\n    Parameters:\n        v: The variable to add to the adjustment set.\n\n    Returns:\n        A list of causal graph edits that correspond to the addition of v to the adjustment set.\n    \"\"\"\n\n    e = []\n    if v in nx.descendants(self.graph, self.treatment) or v in nx.descendants(\n        self.graph, self.outcome\n    ):\n        paths = self._find_directed_paths(\n            self.treatment, v\n        ) + self._find_directed_paths(v, self.outcome)\n        for p in paths:\n            edit = self._break_path_near(p, v)\n            if edit is None:\n                return []\n            e.append(edit)\n    e.append(EdgeEdit(v, self.treatment, EdgeEditType.ADD))\n    e.append(EdgeEdit(v, self.outcome, EdgeEditType.ADD))\n    return list(set(e))\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph.map_removal","title":"<code>map_removal(v, use_optimized=True)</code>","text":"<p>Map a removal from the adjustment set to a list of causal graph edits.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable to remove from the adjustment set.</p> required <code>use_optimized</code> <code>bool</code> <p>Whether to use the optimized version of the function, developed after the ECCS paper.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A list of causal graph edits that correspond to the removal of v from the adjustment set. If the</p> <code>list[EdgeEdit]</code> <p>returned list is empty, the removal was unsuccessful.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def map_removal(\n    self,\n    v: str,\n    use_optimized: bool = True,\n) -&gt; list[EdgeEdit]:\n    \"\"\"\n    Map a removal from the adjustment set to a list of causal graph edits.\n\n    Parameters:\n        v: The variable to remove from the adjustment set.\n        use_optimized: Whether to use the optimized version of the function, developed after the ECCS paper.\n\n    Returns:\n        A list of causal graph edits that correspond to the removal of v from the adjustment set. If the\n        returned list is empty, the removal was unsuccessful.\n    \"\"\"\n\n    if use_optimized:\n        return self._optimized_map_removal(v)\n    return self._unoptimized_map_removal(v)\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._optimized_map_removal","title":"<code>_optimized_map_removal(v)</code>","text":"<p>Map a removal from the adjustment set to a list of causal graph edits. This is the version of this function developed after the ECCS paper.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable to remove from the adjustment set.</p> required <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A list of causal graph edits that correspond to the removal of v from the adjustment set. If</p> <code>list[EdgeEdit]</code> <p>the returned list is empty, the removal was unsuccessful.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _optimized_map_removal(\n    self,\n    v: str,\n) -&gt; list[EdgeEdit]:\n    \"\"\"\n    Map a removal from the adjustment set to a list of causal graph edits. This is the version of\n    this function developed after the ECCS paper.\n\n    Parameters:\n        v: The variable to remove from the adjustment set.\n\n    Returns:\n        A list of causal graph edits that correspond to the removal of v from the adjustment set. If\n        the returned list is empty, the removal was unsuccessful.\n    \"\"\"\n\n    v_descendants = nx.descendants(self.graph, v)\n    t_bfs_descendants = self._BFS_descendants(self.treatment)\n    t_bfs_descendants_and_v_descendants = []\n\n    # First search among descendants that don't need path breaking.\n    for w in t_bfs_descendants:\n        if (w, v) in self.ban_list:\n            continue\n\n        if w in v_descendants:\n            t_bfs_descendants_and_v_descendants.append(w)\n            continue\n\n        return [EdgeEdit(w, v, EdgeEditType.ADD)]\n\n    # If unsuccessful, next search among descendants that need path breaking.\n    best_S = []\n    for w in t_bfs_descendants_and_v_descendants:\n        S, success = self._break_paths(v, w)\n        if not success:\n            continue\n        if not self._is_reachable_with_ignored_edges(\n            self.treatment, w, [e.edge for e in S]\n        ):\n            continue\n        S.append(EdgeEdit(w, v, EdgeEditType.ADD))\n        if len(S) &lt; len(best_S) or len(best_S) == 0:\n            best_S = S\n\n    return best_S\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._unoptimized_map_removal","title":"<code>_unoptimized_map_removal(v)</code>","text":"<p>Map a removal from the adjustment set to a list of causal graph edits. This is the version of this function presented in the ECCS paper.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable to remove from the adjustment set.</p> required <p>Returns:</p> Type Description <code>list[EdgeEdit]</code> <p>A list of causal graph edits that correspond to the removal of v from the adjustment set. If</p> <code>list[EdgeEdit]</code> <p>the returned list is empty, the removal was unsuccessful.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _unoptimized_map_removal(\n    self,\n    v: str,\n) -&gt; list[EdgeEdit]:\n    \"\"\"\n    Map a removal from the adjustment set to a list of causal graph edits. This is the version of\n    this function presented in the ECCS paper.\n\n    Parameters:\n        v: The variable to remove from the adjustment set.\n\n    Returns:\n        A list of causal graph edits that correspond to the removal of v from the adjustment set. If\n        the returned list is empty, the removal was unsuccessful.\n    \"\"\"\n\n    e = []\n    if v in nx.ancestors(self.graph, self.treatment):\n        paths = self._find_directed_paths(v, self.treatment)\n        for p in paths:\n            edit = self._break_path_near(p, v)\n            if edit is None:\n                return []\n            e.append(edit)\n\n    ord_desc = self._find_ordered_descendants(self.treatment)\n    for w in ord_desc:\n        if not (w, v) in self.ban_list:\n            if (v, w) in self.graph.edges:\n                e.append(EdgeEdit(v, w, EdgeEditType.FLIP))\n            else:\n                e.append(EdgeEdit(w, v, EdgeEditType.ADD))\n            return list(set(e))\n    return []\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._all_reachable_with_ignored_edges","title":"<code>_all_reachable_with_ignored_edges(source, ignore=None, reverse=False)</code>","text":"<p>Perform a breadth-first search starting from a source node, ignoring certain edges, and return a list of reachable nodes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The source node.</p> required <code>ignore</code> <code>Optional[set[Edge]]</code> <p>The edges to ignore.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to perform the search in the reverse directed graph.</p> <code>False</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of reachable nodes.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _all_reachable_with_ignored_edges(\n    self, source: str, ignore: Optional[set[Edge]] = None, reverse: bool = False\n) -&gt; set[str]:\n    \"\"\"\n    Perform a breadth-first search starting from a source node, ignoring certain edges,\n    and return a list of reachable nodes.\n\n    Parameters:\n        source: The source node.\n        ignore: The edges to ignore.\n        reverse: Whether to perform the search in the reverse directed graph.\n\n    Returns:\n        A set of reachable nodes.\n    \"\"\"\n\n    queue = deque([source])\n    visited = set([source])\n\n    if reverse:\n        next_nodes = self.graph.predecessors\n        edge_is_ignored = (\n            (lambda x, y: (y, x) in ignore) if ignore else (lambda x, y: False)\n        )\n    else:\n        next_nodes = self.graph.successors\n        edge_is_ignored = (\n            (lambda x, y: (x, y) in ignore) if ignore else (lambda x, y: False)\n        )\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in next_nodes(node):\n            if edge_is_ignored(node, neighbor):\n                continue\n\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return visited\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._is_reachable_with_ignored_edges","title":"<code>_is_reachable_with_ignored_edges(source, sink, ignore)</code>","text":"<p>Check if a sink node is reachable from a source node, ignoring certain edges.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The source node.</p> required <code>sink</code> <code>str</code> <p>The sink node.</p> required <code>ignore</code> <code>set[Edge]</code> <p>The edges to ignore.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the sink node is reachable from the source node.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _is_reachable_with_ignored_edges(\n    self, source: str, sink: str, ignore: set[Edge]\n) -&gt; bool:\n    \"\"\"\n    Check if a sink node is reachable from a source node, ignoring certain edges.\n\n    Parameters:\n        source: The source node.\n        sink: The sink node.\n        ignore: The edges to ignore.\n\n    Returns:\n        A boolean indicating whether the sink node is reachable from the source node.\n    \"\"\"\n\n    return sink in self._all_reachable_with_ignored_edges(source, ignore)\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._break_paths","title":"<code>_break_paths(source, sink, ignore=None)</code>","text":"<p>Break all directed paths between two nodes in a directed graph, ignoring any edges specified in <code>ignore</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The source node.</p> required <code>sink</code> <code>str</code> <p>The sink node.</p> required <code>ignore</code> <code>Optional[set[Edge]]</code> <p>The edges to ignore.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[EdgeEdit], bool]</code> <p>A list of causal graph edits that break all paths between the two nodes, and a boolean indicating success.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _break_paths(\n    self, source: str, sink: str, ignore: Optional[set[Edge]] = None\n) -&gt; tuple[list[EdgeEdit], bool]:\n    \"\"\"\n    Break all directed paths between two nodes in a directed graph, ignoring any edges specified in `ignore`.\n\n    Parameters:\n        source: The source node.\n        sink: The sink node.\n        ignore: The edges to ignore.\n\n    Returns:\n        A list of causal graph edits that break all paths between the two nodes, and a boolean indicating success.\n    \"\"\"\n\n    reachable_from_source = self._all_reachable_with_ignored_edges(source, ignore)\n    sink_reachable_from = self._all_reachable_with_ignored_edges(\n        sink, ignore, reverse=True\n    )\n\n    nodes_to_keep = reachable_from_source.intersection(sink_reachable_from)\n    if len(nodes_to_keep) == 0:\n        return [], True\n\n    B = []\n    queue = deque([source])\n    visited = set([source])\n\n    while queue:\n        V = queue.popleft()\n\n        if V == sink:\n            return [], False\n\n        for W in self.graph.successors(V):\n            if W not in nodes_to_keep:\n                continue\n            if (V, W) not in self.fix_list:\n                B.append(EdgeEdit(V, W, EdgeEditType.REMOVE))\n            elif W not in visited:\n                visited.add(W)\n                queue.append(W)\n\n    return B, True\n</code></pre>"},{"location":"reference/eccs/map_adj_set_to_graph/#eccs.map_adj_set_to_graph.MapAdjSetToGraph._BFS_descendants","title":"<code>_BFS_descendants(v)</code>","text":"<p>Return the descendants of a variable, starting with the variable itself, in breadth-first search order.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The variable.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of descendants in BFS order.</p> Source code in <code>src/eccs/map_adj_set_to_graph.py</code> <pre><code>def _BFS_descendants(self, v: str) -&gt; list[str]:\n    \"\"\"\n    Return the descendants of a variable, starting with the variable itself, in breadth-first search order.\n\n    Parameters:\n        v: The variable.\n\n    Returns:\n        A list of descendants in BFS order.\n    \"\"\"\n    queue = deque([v])\n    visited = [v]\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in self.graph.successors(node):\n            if neighbor not in visited:\n                visited.append(neighbor)\n                queue.append(neighbor)\n\n    return visited\n</code></pre>"},{"location":"reference/evaluation/","title":"Index","text":""},{"location":"reference/evaluation/heuristic_test_runner/","title":"Heuristic test runner","text":""},{"location":"reference/evaluation/iterative_runner/","title":"Iterative runner","text":""},{"location":"reference/evaluation/iterative_runner/#evaluation.iterative_runner.simulate","title":"<code>simulate(args)</code>","text":"<p>Simulate a single run of ECCS user and save the results.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>tuple[DataFrame, dict[str, object], dict[str, object], str, str, str, str, str, int, int, int, bool]</code> <p>a tuple containing: data: The dataset to be used for causal analysis. ground_truth_dag: The ground truth DAG. starting_dag: The starting DAG for the ECCS user. treatment: The name of the treatment variable. outcome: The name of the outcome variable. method: The method to be used to suggest edits. results_path: The path to save the results to. dataset_name: The name of the dataset. num_steps: The number of steps to run the ECCS user for. i: The index of the run, if applicable. astar_budget: The budget for astar, if applicable profile: Whether to enable profiling.</p> required Source code in <code>src/evaluation/iterative_runner.py</code> <pre><code>def simulate(\n    args: tuple[\n        pd.DataFrame,\n        dict[str, object],\n        dict[str, object],\n        str,\n        str,\n        str,\n        str,\n        str,\n        int,\n        int,\n        int,\n        bool\n    ]\n) -&gt; None:\n    \"\"\"\n    Simulate a single run of ECCS user and save the results.\n\n    Parameters:\n        args: a tuple containing:\n            data: The dataset to be used for causal analysis.\n            ground_truth_dag: The ground truth DAG.\n            starting_dag: The starting DAG for the ECCS user.\n            treatment: The name of the treatment variable.\n            outcome: The name of the outcome variable.\n            method: The method to be used to suggest edits.\n            results_path: The path to save the results to.\n            dataset_name: The name of the dataset.\n            num_steps: The number of steps to run the ECCS user for.\n            i: The index of the run, if applicable.\n            astar_budget: The budget for astar, if applicable\n            profile: Whether to enable profiling.\n    \"\"\"\n\n    (\n        data,\n        ground_truth_dag,\n        starting_dag,\n        treatment,\n        outcome,\n        method,\n        results_path,\n        dataset_name,\n        num_steps,\n        i,\n        astar_budget,\n        profile\n    ) = args\n\n    if profile:\n        profiler = cProfile.Profile()\n        profiler.enable()\n\n    f = open(\n        os.path.join(\n            results_path,\n            \"logs\",\n            f\"{dataset_name}_{starting_dag['name']}_{treatment}_{outcome}_{method}{'' if i == None else f'_{i}'}.log\",\n        ),\n        \"w\",\n    )\n    sys.stdout = f\n    sys.stderr = f\n\n    fixed_list = []\n    banned_list = []\n\n    if method.endswith(\"_oracle\"):\n        method = method[:-7]\n        # Create a fixed list out of edges the ground truth and starting dag share\n        fixed_list = [\n            (src, dst)\n            for src, dst in ground_truth_dag[\"graph\"].edges\n            if (src, dst) in starting_dag[\"graph\"].edges\n        ]\n        # Create a banned list out of edges that are in neither the ground truth nor the starting dag\n        all_possible_edges = [\n            (src, dst)\n            for src in ground_truth_dag[\"graph\"].nodes\n            for dst in ground_truth_dag[\"graph\"].nodes\n            if src != dst\n        ]\n        banned_list = [\n            (src, dst)\n            for src, dst in all_possible_edges\n            if (\n                ((src, dst) not in ground_truth_dag[\"graph\"].edges)\n                and ((src, dst) not in starting_dag[\"graph\"].edges)\n            )\n        ]\n\n    # Remove edge attributes from starting dag\n    for _, __, d in starting_dag[\"graph\"].edges(data=True):\n        d.clear()\n\n    try:\n        user = ECCSUser(\n            data,\n            ground_truth_dag[\"graph\"],\n            starting_dag[\"graph\"],\n            treatment,\n            outcome,\n            fixed_list,\n            banned_list,\n        )\n\n        user.run(num_steps, method, astar_budget)\n    except:\n        traceback.print_exc(file=f)\n\n    f.flush()\n\n    exp_prefix = os.path.join(\n        results_path,\n        \"data\",\n        f\"{dataset_name}_{starting_dag['name']}_{treatment}_{outcome}_{method}_{'' if i == None else f'{i}_'}\",\n    )\n\n    np.save(\n        f\"{exp_prefix}ate_trajectory.npy\",\n        user.ate_trajectory,\n    )\n    np.save(\n        f\"{exp_prefix}ate_diff_trajectory.npy\",\n        user.ate_diff_trajectory,\n    )\n    np.save(\n        f\"{exp_prefix}edit_distance_trajectory.npy\",\n        user.edit_distance_trajectory,\n    )\n    np.save(\n        f\"{exp_prefix}invocation_duration_trajectory.npy\",\n        user.invocation_duration_trajectory,\n    )\n    np.save(\n        f\"{exp_prefix}fresh_edits_trajectory.npy\",\n        user.fresh_edits_trajectory,\n    )\n\n    f.close()\n\n    if profile:\n        profiler.disable()\n        profiler.dump_stats(f\"{exp_prefix}_profile.prof\")\n</code></pre>"},{"location":"reference/evaluation/plotter/","title":"Plotter","text":""},{"location":"reference/evaluation/plotter/#evaluation.plotter.plot_edit_distance","title":"<code>plot_edit_distance(ax, method, points, base_path, prefixes)</code>","text":"<p>Plots the edit distance for the given method.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axis to plot on.</p> required <code>method</code> <code>str</code> <p>The method to plot.</p> required <code>points</code> <code>int</code> <p>The number of points to plot.</p> required <code>base_path</code> <code>str</code> <p>The base path to the results.</p> required <code>prefixes</code> <code>list[str]</code> <p>The prefixes of the files to consider.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The maximum plotted value.</p> Source code in <code>src/evaluation/plotter.py</code> <pre><code>def plot_edit_distance(\n    ax: Axes, method: str, points: int, base_path: str, prefixes: list[str]\n) -&gt; float:\n    \"\"\"\n    Plots the edit distance for the given method.\n\n    Parameters:\n        ax: The axis to plot on.\n        method: The method to plot.\n        points: The number of points to plot.\n        base_path: The base path to the results.\n        prefixes: The prefixes of the files to consider.\n\n    Returns:\n        The maximum plotted value.\n    \"\"\"\n\n    accumulator = None\n    file_count = 0\n\n    path = os.path.join(base_path, LINE_FORMATTING_DATA[method][\"path\"], \"data\")\n\n    if not os.path.exists(path):\n        return 0\n\n    for filename in os.listdir(path):\n        if filename.startswith(tuple(prefixes)) and filename.endswith(\n            \"edit_distance_trajectory.npy\"\n        ):\n            # Load the list from the file\n            filepath = os.path.join(path, filename)\n            data = np.load(filepath)\n\n            if len(data) &lt; points:\n                data = np.pad(data, (0, points - len(data)), \"edge\")\n\n            if accumulator is None:\n                accumulator = [float(i) for i in data]\n            else:\n                accumulator += data\n\n            file_count += 1\n\n    if file_count == 0:\n        return 0\n\n    elementwise_average = accumulator / file_count\n\n    ax.plot(\n        range(len(elementwise_average)),\n        elementwise_average,\n        label=LINE_FORMATTING_DATA[method][\"label\"],\n        marker=LINE_FORMATTING_DATA[method][\"marker\"],\n        color=LINE_FORMATTING_DATA[method][\"color\"],\n    )\n\n    return max(elementwise_average)\n</code></pre>"},{"location":"reference/evaluation/plotter/#evaluation.plotter.plot_ate_diff","title":"<code>plot_ate_diff(ax, method, points, base_path, prefixes)</code>","text":"<p>Plots the Absolute Relative ATE Error for the given method.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axis to plot on.</p> required <code>method</code> <code>str</code> <p>The method to plot.</p> required <code>points</code> <code>int</code> <p>The number of points to plot.</p> required <code>base_path</code> <code>str</code> <p>The base path to the results.</p> required <code>prefixes</code> <code>list[str]</code> <p>The prefixes of the files to consider.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The maximum plotted value.</p> Source code in <code>src/evaluation/plotter.py</code> <pre><code>def plot_ate_diff(\n    ax: Axes, method: str, points: int, base_path: str, prefixes: list[str]\n) -&gt; float:\n    \"\"\"\n    Plots the Absolute Relative ATE Error for the given method.\n\n    Parameters:\n        ax: The axis to plot on.\n        method: The method to plot.\n        points: The number of points to plot.\n        base_path: The base path to the results.\n        prefixes: The prefixes of the files to consider.\n\n    Returns:\n        The maximum plotted value.\n    \"\"\"\n\n    accumulator = None\n    file_count = 0\n    count_zeros = 0\n\n    path = os.path.join(base_path, LINE_FORMATTING_DATA[method][\"path\"], \"data\")\n\n    if not os.path.exists(path):\n        return 0\n\n    for filename in os.listdir(path):\n        if filename.startswith(tuple(prefixes)) and filename.endswith(\n            \"ate_diff_trajectory.npy\"\n        ):\n            # Load the list from the file\n            filepath = os.path.join(path, filename)\n            diff_data = np.load(filepath, allow_pickle=True)\n\n            if len(diff_data) &lt; points:\n                diff_data = np.pad(diff_data, (0, points - len(diff_data)), \"edge\")\n\n            if diff_data[-1] == 0:\n                count_zeros += 1\n\n            # Load the ate data to compute ground truth ATE\n            ate_filepath = filepath.replace(\"ate_diff\", \"ate\")\n            ate_data = np.load(ate_filepath, allow_pickle=True)\n            if len(ate_data) &lt; points:\n                ate_data = np.pad(ate_data, (0, points - len(ate_data)), \"edge\")\n\n            ground_truth_ate = ate_data[0] - diff_data[0]\n\n            # Compute the absolute relative ATE error\n            data = np.abs(diff_data / ground_truth_ate)\n\n            for i, v in enumerate(data):\n                if v &lt; 10e-4:\n                    data[i] = 0\n\n            if accumulator is None:\n                accumulator = [float(i) for i in data]\n            else:\n                accumulator += data\n\n            file_count += 1\n\n    print(f\"File count was {file_count}\")\n    print(f\"The final ATE difference was 0 for {count_zeros} files\")\n\n    if file_count == 0:\n        return 0\n\n    elementwise_average = accumulator / file_count\n\n    ax.plot(\n        range(len(elementwise_average)),\n        elementwise_average,\n        label=LINE_FORMATTING_DATA[method][\"label\"],\n        marker=LINE_FORMATTING_DATA[method][\"marker\"],\n        color=LINE_FORMATTING_DATA[method][\"color\"],\n    )\n\n    return max(elementwise_average)\n</code></pre>"},{"location":"reference/evaluation/plotter/#evaluation.plotter.plot_invocation_duration","title":"<code>plot_invocation_duration(ax, method, points, base_path, prefixes)</code>","text":"<p>Plots the duration of each invocation for the given method.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axis to plot on.</p> required <code>method</code> <code>str</code> <p>The method to plot.</p> required <code>points</code> <code>int</code> <p>The number of points to plot.</p> required <code>base_path</code> <code>str</code> <p>The base path to the results.</p> required <code>prefixes</code> <code>list[str]</code> <p>The prefixes of the files to consider.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The maximum plotted value.</p> Source code in <code>src/evaluation/plotter.py</code> <pre><code>def plot_invocation_duration(\n    ax: Axes, method: str, points: int, base_path: str, prefixes: list[str]\n) -&gt; float:\n    \"\"\"\n    Plots the duration of each invocation for the given method.\n\n    Parameters:\n        ax: The axis to plot on.\n        method: The method to plot.\n        points: The number of points to plot.\n        base_path: The base path to the results.\n        prefixes: The prefixes of the files to consider.\n\n    Returns:\n        The maximum plotted value.\n    \"\"\"\n\n    accumulator = [0.0] * points\n    file_counts = [0] * points\n\n    path = os.path.join(base_path, LINE_FORMATTING_DATA[method][\"path\"], \"data\")\n\n    if not os.path.exists(path):\n        return 0\n\n    for filename in os.listdir(path):\n        if filename.startswith(tuple(prefixes)) and filename.endswith(\n            \"invocation_duration_trajectory.npy\"\n        ):\n            # Load the list from the file\n            filepath = os.path.join(path, filename)\n            data = np.load(filepath)\n\n            # Load the freshness data to compute rounds\n            fresh_filepath = filepath.replace(\"invocation_duration\", \"fresh_edits\")\n            fresh_data = np.load(fresh_filepath)\n\n            # Set latency to 0 for rounds where there were no fresh edits\n            for i, v in enumerate(fresh_data):\n                if v == 0:\n                    data[i] = 0\n\n            # Convert to rounds by removing all 0s from the list\n            data = [x for x in data if x &gt; 0]\n\n            for i in range(len(data)):\n                file_counts[i + 1] += 1\n\n            if len(data) &lt; points:\n                data = np.pad(\n                    data, (1, points - len(data) - 1), \"constant\", constant_values=0\n                )\n\n            accumulator += data\n\n    if all(x == 0 for x in file_counts):\n        return 0\n\n    elementwise_average = [\n        i / j if j != 0 else 0 for i, j in zip(accumulator, file_counts)\n    ]\n\n    retval = max(elementwise_average)\n\n    elementwise_average[0] = None\n    elementwise_average = [x for x in elementwise_average if x is None or x &gt; 0]\n\n    ax.plot(\n        range(len(elementwise_average)),\n        elementwise_average,\n        label=LINE_FORMATTING_DATA[method][\"label\"],\n        marker=LINE_FORMATTING_DATA[method][\"marker\"],\n        color=LINE_FORMATTING_DATA[method][\"color\"],\n    )\n\n    return retval\n</code></pre>"},{"location":"reference/evaluation/plotter/#evaluation.plotter.plot_fresh_edits","title":"<code>plot_fresh_edits(ax, method, points, base_path, prefixes)</code>","text":"<p>Plots the number of fresh edits for each invocation for the given method.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axis to plot on.</p> required <code>method</code> <code>str</code> <p>The method to plot.</p> required <code>points</code> <code>int</code> <p>The number of points to plot.</p> required <code>base_path</code> <code>str</code> <p>The base path to the results.</p> required <code>prefixes</code> <code>list[str]</code> <p>The prefixes of the files to consider.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The maximum plotted value.</p> Source code in <code>src/evaluation/plotter.py</code> <pre><code>def plot_fresh_edits(\n    ax: Axes, method: str, points: int, base_path: str, prefixes: list[str]\n) -&gt; float:\n    \"\"\"\n    Plots the number of fresh edits for each invocation for the given method.\n\n    Parameters:\n        ax: The axis to plot on.\n        method: The method to plot.\n        points: The number of points to plot.\n        base_path: The base path to the results.\n        prefixes: The prefixes of the files to consider.\n\n    Returns:\n        The maximum plotted value.\n    \"\"\"\n\n    accumulator = [0] * points\n    file_counts = [0] * points\n\n    path = os.path.join(base_path, LINE_FORMATTING_DATA[method][\"path\"], \"data\")\n\n    if not os.path.exists(path):\n        return 0\n\n    for filename in os.listdir(path):\n        if filename.startswith(tuple(prefixes)) and filename.endswith(\n            \"fresh_edits_trajectory.npy\"\n        ):\n            # Load the list from the file\n            filepath = os.path.join(path, filename)\n            data = np.load(filepath)\n\n            # Convert to rounds by removing all 0s from the list\n            data = [x for x in data if x &gt; 0]\n\n            for i in range(len(data)):\n                file_counts[i + 1] += 1 if data[i] &gt; 0 else 0\n\n            if len(data) &lt; points:\n                orig_len = len(data)\n                data = np.pad(\n                    data, (1, points - orig_len - 1), \"constant\", constant_values=0\n                )\n\n            if accumulator is None:\n                accumulator = data\n            else:\n                accumulator += data\n\n    if all(x == 0 for x in file_counts):\n        return 0\n\n    elementwise_average = [\n        i / j if j != 0 else 0 for i, j in zip(accumulator, file_counts)\n    ]\n\n    if method == \"best_single_adjustment_set_change\":\n        print(file_counts)\n\n    retval = max(elementwise_average)\n\n    elementwise_average[0] = None\n    elementwise_average = [x for x in elementwise_average if x is None or x &gt; 0]\n\n    ax.plot(\n        range(len(elementwise_average)),\n        elementwise_average,\n        label=LINE_FORMATTING_DATA[method][\"label\"],\n        marker=LINE_FORMATTING_DATA[method][\"marker\"],\n        color=LINE_FORMATTING_DATA[method][\"color\"],\n    )\n\n    return retval\n</code></pre>"},{"location":"reference/evaluation/plotter/#evaluation.plotter.plot_zero_ate_diff","title":"<code>plot_zero_ate_diff(ax, method, points, base_path, prefixes)</code>","text":"<p>Plots the fraction of experiments with zero ATE difference at each round.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axis to plot on.</p> required <code>method</code> <code>str</code> <p>The method to plot.</p> required <code>points</code> <code>int</code> <p>The number of points to plot.</p> required <code>base_path</code> <code>str</code> <p>The base path to the results.</p> required <code>prefixes</code> <code>list[str]</code> <p>The prefixes of the files to consider.</p> required Source code in <code>src/evaluation/plotter.py</code> <pre><code>def plot_zero_ate_diff(\n    ax: Axes, method: str, points: int, base_path: str, prefixes: list[str]\n) -&gt; float:\n    \"\"\"\n    Plots the fraction of experiments with zero ATE difference at each round.\n\n    Parameters:\n        ax: The axis to plot on.\n        method: The method to plot.\n        points: The number of points to plot.\n        base_path: The base path to the results.\n        prefixes: The prefixes of the files to consider.\n    \"\"\"\n\n    accumulator = [0] * points\n    file_count = 0\n\n    path = os.path.join(base_path, LINE_FORMATTING_DATA[method][\"path\"], \"data\")\n\n    if not os.path.exists(path):\n        return 0\n\n    for filename in os.listdir(path):\n        if filename.startswith(tuple(prefixes)) and filename.endswith(\n            \"ate_diff_trajectory.npy\"\n        ):\n            # Load the list from the file\n            filepath = os.path.join(path, filename)\n            diff_data = np.load(filepath, allow_pickle=True)\n\n            if len(diff_data) &lt; points:\n                diff_data = np.pad(diff_data, (0, points - len(diff_data)), \"edge\")\n\n            accumulator += (diff_data &lt; 10e-4).astype(int)\n\n            file_count += 1\n\n    if file_count == 0:\n        return 0\n\n    elementwise_average = accumulator / file_count\n\n    ax.plot(\n        range(len(elementwise_average)),\n        elementwise_average,\n        label=LINE_FORMATTING_DATA[method][\"label\"],\n        marker=LINE_FORMATTING_DATA[method][\"marker\"],\n        color=LINE_FORMATTING_DATA[method][\"color\"],\n    )\n\n    return max(elementwise_average)\n</code></pre>"},{"location":"reference/evaluation/plotter/#evaluation.plotter.plot_invocation_duration_scaling","title":"<code>plot_invocation_duration_scaling(ax, method, base_path, prefix_to_data_point)</code>","text":"<p>Plots the duration of each invocation for the given method.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axis to plot on.</p> required <code>method</code> <code>str</code> <p>The method to plot.</p> required <code>base_path</code> <code>str</code> <p>The base path to the results.</p> required <code>prefix_to_data_point</code> <code>dict[str, str]</code> <p>A mapping from file prefix to the data point into which the data of that file should be incorporated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The maximum plotted value.</p> Source code in <code>src/evaluation/plotter.py</code> <pre><code>def plot_invocation_duration_scaling(\n    ax: Axes, method: str, base_path: str, prefix_to_data_point: dict[str, str]\n) -&gt; float:\n    \"\"\"\n    Plots the duration of each invocation for the given method.\n\n    Parameters:\n        ax: The axis to plot on.\n        method: The method to plot.\n        base_path: The base path to the results.\n        prefix_to_data_point: A mapping from file prefix to the data point into\n            which the data of that file should be incorporated.\n\n    Returns:\n        The maximum plotted value.\n    \"\"\"\n\n    data_points = set(prefix_to_data_point.values())\n\n    accumulators = {data_point: 0.0 for data_point in data_points}\n    invocation_counts = {data_point: 0 for data_point in data_points}\n\n    path = os.path.join(base_path, LINE_FORMATTING_DATA[method][\"path\"], \"data\")\n\n    if not os.path.exists(path):\n        return 0\n\n    for filename in os.listdir(path):\n        if filename.endswith(\"invocation_duration_trajectory.npy\"):\n            # Load the list from the file\n            filepath = os.path.join(path, filename)\n            data = np.load(filepath)\n            data_point = prefix_to_data_point[filename[:12]]\n\n            # Load the freshness data to compute rounds\n            fresh_filepath = filepath.replace(\"invocation_duration\", \"fresh_edits\")\n            fresh_data = np.load(fresh_filepath)\n\n            # Set latency to 0 for rounds where there were no fresh edits, and count the\n            # invocation otherwise.\n            for i, v in enumerate(fresh_data):\n                if v == 0:\n                    data[i] = 0\n                else:\n                    invocation_counts[data_point] += 1\n\n            # Accumulate the right data point\n            accumulators[data_point] += sum(data)\n\n    if all(x == 0 for x in invocation_counts):\n        return 0\n\n    elementwise_average = {\n        data_point: (\n            accumulators[data_point] / invocation_counts[data_point]\n            if invocation_counts[data_point] != 0\n            else 0\n        )\n        for data_point in data_points\n    }\n\n    ax.plot(\n        elementwise_average.keys(),\n        elementwise_average.values(),\n        label=LINE_FORMATTING_DATA[method][\"label\"],\n        marker=LINE_FORMATTING_DATA[method][\"marker\"],\n        color=LINE_FORMATTING_DATA[method][\"color\"],\n    )\n\n    return max(elementwise_average.values())\n</code></pre>"},{"location":"reference/evaluation/plotter/#evaluation.plotter.wrapup_plot","title":"<code>wrapup_plot(filename, ax, max_val, log_y_axis=False, x_unit='Judgment')</code>","text":"<p>Set final formatting for the plot and save it to a file. Also print stats about the plotted lines to another file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save the plot to.</p> required <code>ax</code> <code>Axes</code> <p>The axis to save.</p> required <code>max_val</code> <code>float</code> <p>The maximum value of the plotted data.</p> required <code>log_y_axis</code> <code>bool</code> <p>Whether to use a log scale for the y-axis.</p> <code>False</code> <code>x_unit</code> <code>str</code> <p>The units of the x axis (\"Judgment\" or \"Round\")</p> <code>'Judgment'</code> Source code in <code>src/evaluation/plotter.py</code> <pre><code>def wrapup_plot(\n    filename: str,\n    ax: Axes,\n    max_val: float,\n    log_y_axis: bool = False,\n    x_unit: str = \"Judgment\",\n) -&gt; None:\n    \"\"\"\n    Set final formatting for the plot and save it to a file. Also print stats about the plotted\n    lines to another file.\n\n    Parameters:\n        filename: The name of the file to save the plot to.\n        ax: The axis to save.\n        max_val: The maximum value of the plotted data.\n        log_y_axis: Whether to use a log scale for the y-axis.\n        x_unit: The units of the x axis (\"Judgment\" or \"Round\")\n    \"\"\"\n\n    # Deal with the stats\n    num_points = 0\n    with open(filename + \".csv\", \"w\") as f:\n        f.write(\"label,last_y,average_y\\n\")\n        for line in ax.get_lines():\n            y_data = line.get_ydata()\n            if len(y_data) &gt; num_points:\n                num_points = len(y_data)\n            y_data = [x for x in y_data if x is not None]\n            f.write(f\"{line.get_label()},{y_data[-1]},{np.mean(y_data)}\\n\")\n\n    # Deal with the figure\n    ax.tick_params(axis=\"both\", which=\"major\", labelsize=FONTSIZE)\n    if x_unit == \"Judgment\" or x_unit == \"Round\":\n        x_unit = f\"{x_unit} \" + r\"\\#\"\n        ax.set_xticks(np.arange(0, num_points, 2))\n    elif len(ax.get_lines()) &gt; 0:\n        ax.set_xticks(ax.get_lines()[0].get_xdata())\n    ax.set_xlabel(x_unit, fontsize=FONTSIZE)\n    ax.legend(fontsize=FONTSIZE)\n    if log_y_axis:\n        ax.set_yscale(\"log\")\n        ax.set_ylim(0.001, 10 ** (1.1 * np.log10(max_val)))\n    else:\n        ax.set_ylim(0, 1.1 * max_val)\n    if (\n        False\n    ):  # These are the hard-coded y limits for /home/markakis/eccs/evaluation/2024-04-05 12:10:57.816692\n        if \"edit_distance\" in filename:\n            ax.set_ylim(0, 24.432597305389223)\n        elif \"ate_error\" in filename:\n            ax.set_ylim(0, 0.6739732398970182)\n        elif \"invocation_duration\" in filename:\n            ax.set_ylim(0.001, 253.37828732457606)\n        elif \"fresh_edits\" in filename:\n            ax.set_ylim(0, 4.776765147721583)\n        elif \"zero_ate_diff\" in filename:\n            ax.set_ylim(0, 0.8694610778443115)\n\n    plt.tight_layout()\n    plt.savefig(filename + \".png\", dpi=300)\n    plt.cla()\n</code></pre>"},{"location":"reference/evaluation/plotter/#evaluation.plotter.plotter","title":"<code>plotter(path, skip=False)</code>","text":"<p>Plot the experiment data at <code>path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the experiment data.</p> required <code>skip</code> <code>bool</code> <p>Whether to skip re-generating plots that exist.</p> <code>False</code> Source code in <code>src/evaluation/plotter.py</code> <pre><code>def plotter(path: str, skip: bool = False):\n    \"\"\"\n    Plot the experiment data at `path`.\n\n    Parameters:\n        path: The path to the experiment data.\n        skip: Whether to skip re-generating plots that exist.\n    \"\"\"\n\n    # Load the experiment configuration file\n    with open(os.path.join(path, \"config.yml\"), \"r\") as f:\n        config = yaml.safe_load(f)\n    num_points = 1 + config[\"run_eccs\"][\"num_steps\"]\n\n    # Create a directory for the plots\n    plots_path = os.path.join(path, \"plots\")\n    os.makedirs(plots_path, exist_ok=True)\n\n    # Figure out the ground truth dags for each parameter combination\n    if type(config[\"gen_dag\"][\"num_nodes\"]) != list:\n        config[\"gen_dag\"][\"num_nodes\"] = [config[\"gen_dag\"][\"num_nodes\"]]\n    if type(config[\"gen_dag\"][\"edge_prob\"]) != list:\n        config[\"gen_dag\"][\"edge_prob\"] = [config[\"gen_dag\"][\"edge_prob\"]]\n    combinations = [\n        (num_nodes, edge_prob)\n        for num_nodes in config[\"gen_dag\"][\"num_nodes\"]\n        for edge_prob in config[\"gen_dag\"][\"edge_prob\"]\n    ]\n    combination_to_ground_truth_dags = {}\n    for file in os.listdir(os.path.join(path, \"ground_truth_dags\")):\n        if file.endswith(\".json\"):\n            name = file[:12]\n            with open(os.path.join(path, \"ground_truth_dags\", file), \"r\") as f:\n                params = json.load(f)\n            combination_to_ground_truth_dags.setdefault(\n                (params[\"num_nodes\"], params[\"edge_prob\"]), []\n            ).append(name)\n\n    for num_nodes, edge_prob in combinations:\n        print(f\"Plotting for num_nodes={num_nodes}, edge_prob={edge_prob}...\")\n        prefixes = combination_to_ground_truth_dags[(num_nodes, edge_prob)]\n\n        # Create a directory for the plots\n        comb_plots_path = os.path.join(\n            plots_path, f\"num_nodes={num_nodes}_edge_prob={edge_prob}\"\n        )\n        os.makedirs(comb_plots_path, exist_ok=True)\n\n        ### Graph edit distance\n        print(\"Plotting graph edit distance...\")\n        if skip and os.path.exists(os.path.join(comb_plots_path, \"edit_distance.png\")):\n            print(\"Skipping edit distance plot\")\n        else:\n            _, ax = plt.subplots()\n            max_y = 0\n            for method in LINE_FORMATTING_DATA:\n                max_y = max(\n                    max_y,\n                    plot_edit_distance(ax, method, num_points, path, prefixes),\n                )\n            ax.set_ylabel(\"Graph Edit Distance\", fontsize=FONTSIZE)\n            wrapup_plot(os.path.join(comb_plots_path, \"edit_distance\"), ax, max_y)\n\n        ### ATE difference\n        print(\"Plotting ATE difference...\")\n        if skip and os.path.exists(os.path.join(comb_plots_path, \"ate_error.png\")):\n            print(\"Skipping ATE Error plot\")\n        else:\n            _, ax = plt.subplots()\n            max_y = 0\n            for method in LINE_FORMATTING_DATA:\n                max_y = max(\n                    max_y, plot_ate_diff(ax, method, num_points, path, prefixes)\n                )\n            ax.set_ylabel(\"ARE_ATE\", fontsize=FONTSIZE)\n            wrapup_plot(os.path.join(comb_plots_path, \"ate_error\"), ax, max_y)\n\n        ### Invocation Duration\n        print(\"Plotting Invocation Duration...\")\n        if skip and os.path.exists(\n            os.path.join(comb_plots_path, \"invocation_duration.png\")\n        ):\n            print(\"Skipping Invocation Duration plot\")\n        else:\n            _, ax = plt.subplots()\n            max_y = 0\n            for method in LINE_FORMATTING_DATA:\n                max_y = max(\n                    max_y,\n                    plot_invocation_duration(ax, method, num_points, path, prefixes),\n                )\n\n            ax.set_ylabel(\"ECCS Latency (s)\", fontsize=FONTSIZE)\n            wrapup_plot(\n                os.path.join(comb_plots_path, \"invocation_duration\"),\n                ax,\n                max_y,\n                log_y_axis=True,\n                x_unit=\"Round\",\n            )\n\n        ### Number of fresh edits\n        print(\"Plotting Fresh Edits...\")\n        if skip and os.path.exists(os.path.join(comb_plots_path, \"fresh_edits.png\")):\n            print(\"Skipping Fresh Edits plot\")\n        else:\n            _, ax = plt.subplots()\n            max_y = 0\n            for method in LINE_FORMATTING_DATA:\n                max_y = max(\n                    max_y, plot_fresh_edits(ax, method, num_points, path, prefixes)\n                )\n\n            ax.set_ylabel(r\"\\# Fresh Edits\", fontsize=FONTSIZE)\n            wrapup_plot(\n                os.path.join(comb_plots_path, \"fresh_edits\"), ax, max_y, x_unit=\"Round\"\n            )\n\n        ### Fraction of experiments with zero ATE difference at that round\n        print(\"Plotting Fraction of experiments with zero ATE difference...\")\n        if skip and os.path.exists(os.path.join(comb_plots_path, \"zero_ate_diff.png\")):\n            print(\"Skipping Zero ATE Difference plot\")\n        else:\n            _, ax = plt.subplots()\n            max_y = 0\n            for method in LINE_FORMATTING_DATA:\n                max_y = max(\n                    max_y, plot_zero_ate_diff(ax, method, num_points, path, prefixes)\n                )\n\n            ax.set_ylabel(\n                \"Fraction of Experiments with\\nZero ARE_ATE\", fontsize=FONTSIZE\n            )\n            wrapup_plot(\n                os.path.join(comb_plots_path, \"zero_ate_diff\"),\n                ax,\n                max_y,\n                x_unit=\"Round\",\n            )\n\n    ### Latency scaling by num_nodes\n    print(\"Plotting latency scaling by num_nodes...\")\n    if skip and os.path.exists(os.path.join(plots_path, \"scaling_num_nodes.png\")):\n        print(\"Skipping latency scaling by num_nodes plot\")\n    else:\n        _, ax = plt.subplots()\n        max_y = 0\n        prefix_to_data_point = {\n            prefix: num_nodes\n            for (num_nodes, _), prefixes in combination_to_ground_truth_dags.items()\n            for prefix in prefixes\n        }\n\n        for method in LINE_FORMATTING_DATA:\n            max_y = max(\n                max_y,\n                plot_invocation_duration_scaling(\n                    ax, method, path, prefix_to_data_point\n                ),\n            )\n        ax.set_ylabel(\"ECCS Latency (s)\", fontsize=FONTSIZE)\n        wrapup_plot(\n            os.path.join(plots_path, \"scaling_num_nodes\"), ax, max_y, x_unit=\"Num Nodes\"\n        )\n\n    ### Latency scaling by edge_prob\n    print(\"Plotting latency scaling by edge_prob...\")\n    if skip and os.path.exists(os.path.join(plots_path, \"scaling_edge_prob.png\")):\n        print(\"Skipping latency scaling by edge_prob plot\")\n    else:\n        _, ax = plt.subplots()\n        max_y = 0\n        prefix_to_data_point = {\n            prefix: edge_prob\n            for (_, edge_prob), prefixes in combination_to_ground_truth_dags.items()\n            for prefix in prefixes\n        }\n        for method in LINE_FORMATTING_DATA:\n            max_y = max(\n                max_y,\n                plot_invocation_duration_scaling(\n                    ax, method, path, prefix_to_data_point\n                ),\n            )\n        ax.set_ylabel(\"ECCS Latency (s)\", fontsize=FONTSIZE)\n        wrapup_plot(\n            os.path.join(plots_path, \"scaling_edge_prob\"),\n            ax,\n            max_y,\n            x_unit=\"Edge Probability\",\n        )\n</code></pre>"},{"location":"reference/evaluation/simple_runner/","title":"Simple runner","text":""},{"location":"reference/evaluation/user/","title":"User","text":""},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser","title":"<code>ECCSUser</code>","text":"<p>A class simulating a user of the ECCS system.</p> <p>The user knows the ground truth causal graph and responds to the system's suggestions accordingly.</p> Source code in <code>src/evaluation/user.py</code> <pre><code>class ECCSUser:\n    \"\"\"\n    A class simulating a user of the ECCS system.\n\n    The user knows the ground truth causal graph and responds to the system's suggestions\n    accordingly.\n    \"\"\"\n\n    ate_calculator = ATECalculator()\n\n    def __init__(\n        self,\n        data: str | pd.DataFrame,\n        true_graph: str | nx.DiGraph,\n        test_graph: str | nx.DiGraph,\n        treatment: str,\n        outcome: str,\n        fixed: Optional[list[Edge]] = None,\n        banned: Optional[list[Edge]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the ECCSUser object.\n\n        Parameters:\n            data: The dataset or the path to it.\n            true_graph: The ground truth causal graph or the path to it.\n            test_graph: The starting graph available to the user or the path to it.\n            treatment: The name of the treatment variable.\n            outcome: The name of the outcome variable.\n            fixed: An optional list of fixed edges at the start.\n            banned: An optional list of banned edges at the start.\n        \"\"\"\n\n        if isinstance(data, str):\n            self._data = pd.read_csv(data)\n        else:\n            self._data = data\n\n        if isinstance(true_graph, str):\n            self._true_graph = nx.DiGraph(nx.nx_pydot.read_dot(true_graph))\n        else:\n            self._true_graph = true_graph\n\n        if isinstance(test_graph, str):\n            self._test_graph = nx.DiGraph(nx.nx_pydot.read_dot(test_graph))\n        else:\n            self._test_graph = test_graph\n\n        self._treatment = treatment\n        self._outcome = outcome\n\n        self._eccs = ECCS(data, test_graph)\n        self._eccs.set_treatment(treatment)\n        self._eccs.set_outcome(outcome)\n        self._true_ate = None\n        self._current_ate = None\n\n        # This is the index of steps where algorithms that might suggest multiple\n        # edges in one invocation got invoked, for plotting and data analysis\n        # purposes\n        self._eccs_algorithm_invocation_iters = []\n\n        self._invocations = 0\n        self._ate_trajectory = [self.current_ate]\n        self._edit_disance_trajectory = [self.current_graph_edit_distance]\n        self._invocation_duration_trajectory = []\n        self._fresh_edits_trajectory = []\n\n        if fixed:\n            for edge in fixed:\n                if self._eccs.get_edge_state(*edge) == EdgeState.PRESENT:\n                    self._eccs.fix_edge(*edge)\n                else:\n                    print(\n                        f\"Warning: Fixed edge {edge} is not present in the graph. It has state {EdgeState(state)}. Skipping.\"\n                    )\n\n        if banned:\n            for edge in banned:\n                state = self._eccs.get_edge_state(*edge)\n                if state == EdgeState.ABSENT:\n                    self._eccs.ban_edge(*edge)\n                elif (\n                    state != EdgeState.BANNED\n                ):  # May be already banned because we fixed its reverse.\n                    print(\n                        f\"Warning: Banned edge {edge} is not absent/banned from the graph. It has state {EdgeState(state)}. Skipping.\"\n                    )\n\n        print(\"Initialized ECCS user!\")\n        print(f\"True ATE: {self.true_ate}\")\n        print(f\"Initial ATE: {self.current_ate}\")\n        print(f\"Initial ATE difference: {self.current_ate_diff}\")\n        print(f\"Initial edit distance: {self.current_graph_edit_distance}\")\n        print(f\"An optimal edit path: {self.current_optimal_edit_path}\")\n\n    @property\n    def true_ate(self) -&gt; float:\n        \"\"\"\n        Returns the true ATE of the treatment on the outcome.\n\n        Returns:\n            The true ATE of the treatment on the outcome, or\n            None if the graph does not contain a directed path from the treatment to the outcome.\n        \"\"\"\n        if self._true_ate is None:\n            if nx.has_path(self._true_graph, self._treatment, self._outcome):\n                self._true_ate = self.ate_calculator.get_ate_and_confidence(\n                    self._data, self._treatment, self._outcome, self._true_graph\n                )[\"ATE\"]\n            else:\n                self._true_ate = 0\n        return self._true_ate\n\n    @property\n    def current_ate(self) -&gt; float:\n        \"\"\"\n        Returns the current ATE of the treatment on the outcome.\n\n        Returns:\n            The ATE of the treatment on the outcome based on the current graph, or\n            None if the graph does not contain a directed path from the treatment to the outcome.\n        \"\"\"\n        return self._eccs.get_ate()\n\n    @property\n    def current_ate_diff(self) -&gt; float:\n        \"\"\"\n        Returns the difference between the current ATE and the true ATE.\n\n        Returns:\n            The difference between the current ATE and the true ATE, or\n            None if either graph does not contain a directed path from the treatment to the outcome.\n        \"\"\"\n        return self.current_ate - self.true_ate\n\n    @property\n    def current_graph_edit_distance(self) -&gt; int:\n        \"\"\"\n        Returns the edit distance between the current graph and the true graph.\n\n        Returns:\n            The edit distance between the current graph and the true graph.\n        \"\"\"\n\n        nodes = set(self._eccs.graph.nodes()).union(set(self._true_graph.nodes()))\n        edit_distance = 0\n\n        # Increment distance for every true edge that is currently missing\n        for edge in self._true_graph.edges():\n            if edge not in self._eccs.graph.edges():\n                edit_distance += 1\n\n        # Increment distance for every edge that is currently present but should not be,\n        # unless its reverse is present in the true graph, in which case we already counted it above\n        # (an edge flip counts as a single operation)\n        for edge in self._eccs.graph.edges():\n            if (\n                edge not in self._true_graph.edges()\n                and edge[::-1] not in self._true_graph.edges()\n            ):\n                edit_distance += 1\n\n        return edit_distance\n\n    @property\n    def current_optimal_edit_path(self) -&gt; list[tuple]:\n        \"\"\"\n        Returns the optimal edit path between the current graph and the true graph.\n\n        Returns:\n            The optimal edit path between the current graph and the true graph.\n        \"\"\"\n\n        changes = []\n\n        for edge in self._true_graph.edges():\n            if edge not in self._eccs.graph.edges():\n                if edge[::-1] in self._eccs.graph.edges():\n                    changes.append((edge[::-1], edge, EdgeEditType.FLIP))\n                else:\n                    changes.append((edge, None, EdgeEditType.ADD))\n\n        for edge in self._eccs.graph.edges():\n            if (\n                edge not in self._true_graph.edges()\n                and edge[::-1] not in self._true_graph.edges()\n            ):\n                changes.append((edge, None, EdgeEditType.REMOVE))\n\n        return changes\n\n    @property\n    def invocations(self) -&gt; int:\n        \"\"\"\n        Returns the number of invocations of the ECCS system so far.\n\n        Returns:\n            The number of invocations of the ECCS system.\n        \"\"\"\n        return self._invocations\n\n    @property\n    def ate_trajectory(self) -&gt; list[float]:\n        \"\"\"\n        Returns the trajectory of the ATE over the invocations.\n\n        Returns:\n            The trajectory of the ATE over the invocations.\n        \"\"\"\n        return self._ate_trajectory\n\n    @property\n    def ate_diff_trajectory(self) -&gt; list[float]:\n        \"\"\"\n        Returns the trajectory of the ATE difference over the invocations.\n\n        Returns:\n            The trajectory of the ATE difference over the invocations.\n        \"\"\"\n        return [ate - self.true_ate for ate in self._ate_trajectory]\n\n    @property\n    def edit_distance_trajectory(self) -&gt; list[int]:\n        \"\"\"\n        Returns the trajectory of the graph edit distance over the invocations.\n\n        Returns:\n            The trajectory of the graph edit distance over the invocations.\n        \"\"\"\n        return self._edit_disance_trajectory\n\n    @property\n    def invocation_duration_trajectory(self) -&gt; list[float]:\n        \"\"\"\n        Returns the trajectory of the invocation durations over the invocations.\n\n        Returns:\n            The trajectory of the invocation durations over the invocations.\n        \"\"\"\n        return self._invocation_duration_trajectory\n\n    @property\n    def fresh_edits_trajectory(self) -&gt; list[int]:\n        \"\"\"\n        Returns the trajectory of the number of fresh edits per invocation over the invocations.\n        Edits are fresh when the underlying algorithm was actually invoked to produce them (as\n        opposed to serving them from a cache).\n\n        Returns:\n            The trajectory of the number of fresh edits per invocation over the invocations.\n        \"\"\"\n        return self._fresh_edits_trajectory\n\n    def invoke_eccs(\n        self, method: str = None, budget: int = None, max_judgments: int = None\n    ) -&gt; tuple[bool, int]:\n        \"\"\"\n        Invokes the ECCS system and updates the fixed and banned nodes accordingly.\n\n        Parameters:\n            method: The method to use for edge suggestions.\n            budget: The budget for the invocation. Not all methods use this.\n            max_judgments: The maximum number of edits to produce a judgment for. If None,\n                the system will produce a judgment for all suggested edits provided by a single\n                invocation of the ECCS system.\n\n        Returns:\n            A tuple containing whether any edits were suggested and how many fresh edits were produced\n            during this invocation.\n        \"\"\"\n\n        if (method is None) or (method not in self._eccs.EDGE_SUGGESTION_METHODS):\n            method = self._eccs.EDGE_SUGGESTION_METHODS[0]\n\n        # Get suggested modifications and selectively apply them\n        start = datetime.now()\n        edits, ate, num_fresh_edits = self._eccs.suggest(\n            method, budget, max_results=max_judgments\n        )\n        end = datetime.now()\n        self._invocation_duration_trajectory.append((end - start).total_seconds())\n        self._fresh_edits_trajectory.append(num_fresh_edits)\n        print(\n            f\"In iteration {self._invocations + 1} ECCS suggested: {edits} in {self._invocation_duration_trajectory[-1]} seconds.\"\n        )\n        if len(edits) == 0:\n            return (False, 0)\n        for src, dst, _ in edits:\n            fadd = frem = ffix = fban = False\n            radd = rrem = rfix = rban = False\n\n            # The user produces the right judgement for the pair of (src, dst) regardless of the suggested edit type.\n            if (src, dst) in self._true_graph.edges():\n                fadd = self._eccs.add_edge(src, dst)\n                ffix = self._eccs.fix_edge(src, dst)\n                rrem = self._eccs.remove_edge(dst, src, remove_isolates=False)\n                rban = self._eccs.ban_edge(dst, src)\n            elif (dst, src) in self._true_graph.edges():\n                frem = self._eccs.remove_edge(src, dst, remove_isolates=False)\n                fban = self._eccs.ban_edge(src, dst)\n                radd = self._eccs.add_edge(dst, src)\n                rfix = self._eccs.fix_edge(dst, src)\n            else:\n                frem = self._eccs.remove_edge(src, dst, remove_isolates=False)\n                fban = self._eccs.ban_edge(src, dst)\n                rrem = self._eccs.remove_edge(dst, src, remove_isolates=False)\n                rban = self._eccs.ban_edge(dst, src)\n\n            self._current_ate = None\n\n            print(\n                f\"\\tUser judgement for edge {src} -&gt; {dst}: \"\n                + (\"Add \" if fadd else \"\")\n                + (\"Remove \" if frem else \"\")\n                + (\"Fix \" if ffix else \"\")\n                + (\"Ban \" if fban else \"\")\n            )\n            print(\n                f\"\\tUser judgement for edge {dst} -&gt; {src}: \"\n                + (\"Add \" if radd else \"\")\n                + (\"Remove \" if rrem else \"\")\n                + (\"Fix \" if rfix else \"\")\n                + (\"Ban \" if rban else \"\")\n            )\n\n        # Update bookkeeping\n        self._invocations += 1\n        self._ate_trajectory.append(self.current_ate)\n        self._edit_disance_trajectory.append(self.current_graph_edit_distance)\n\n        print(f\"\\tUpdated ATE: {self.current_ate} (from {self.ate_trajectory[-2]})\")\n        print(\n            f\"\\tUpdated ATE difference: {self.current_ate_diff} (from {self.ate_diff_trajectory[-2]})\"\n        )\n        print(\n            f\"\\tUpdated edit distance: {self.current_graph_edit_distance} (from {self.edit_distance_trajectory[-2]})\"\n        )\n        return (True, num_fresh_edits)\n\n    def run(self, steps: int, method: str = None, budget: int = None) -&gt; None:\n        \"\"\"\n        Simulate the user for `steps` steps. In each step, the user invokes the ECCS\n        system and updates the fixed and banned edges accordingly.\n\n        Parameters:\n            steps: The number of steps that the user executes\n            method: The method to use for edge suggestions.\n            budget: The budget for each invocation. Not all methods use this.\n        \"\"\"\n\n        for i in range(steps):\n            print(f\"Running iteration {i + 1}\")\n            suggested_edits, num_fresh_edits = self.invoke_eccs(\n                method, budget, max_judgments=1\n            )\n            if num_fresh_edits &gt; 0:\n                self._eccs_algorithm_invocation_iters.append(i)\n            if not suggested_edits:\n                print(\n                    \"ECCS suggested no changes. Stopping. \",\n                    \"Total fresh edits produced over time: \",\n                    sum(self._fresh_edits_trajectory),\n                    \"Total algorithm invocations: \",\n                    len(self._eccs_algorithm_invocation_iters),\n                    \"Final edit distance: \",\n                    self.current_graph_edit_distance,\n                    \"Final ATE: \",\n                    self.current_ate,\n                    \"Final ATE difference: \",\n                    self.current_ate_diff,\n                )\n                break\n        print(\n            \"The specific ECCS Algorithm was invoked in the following steps: \",\n            self._eccs_algorithm_invocation_iters,\n        )\n</code></pre>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.true_ate","title":"<code>true_ate: float</code>  <code>property</code>","text":"<p>Returns the true ATE of the treatment on the outcome.</p> <p>Returns:</p> Type Description <code>float</code> <p>The true ATE of the treatment on the outcome, or</p> <code>float</code> <p>None if the graph does not contain a directed path from the treatment to the outcome.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.current_ate","title":"<code>current_ate: float</code>  <code>property</code>","text":"<p>Returns the current ATE of the treatment on the outcome.</p> <p>Returns:</p> Type Description <code>float</code> <p>The ATE of the treatment on the outcome based on the current graph, or</p> <code>float</code> <p>None if the graph does not contain a directed path from the treatment to the outcome.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.current_ate_diff","title":"<code>current_ate_diff: float</code>  <code>property</code>","text":"<p>Returns the difference between the current ATE and the true ATE.</p> <p>Returns:</p> Type Description <code>float</code> <p>The difference between the current ATE and the true ATE, or</p> <code>float</code> <p>None if either graph does not contain a directed path from the treatment to the outcome.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.current_graph_edit_distance","title":"<code>current_graph_edit_distance: int</code>  <code>property</code>","text":"<p>Returns the edit distance between the current graph and the true graph.</p> <p>Returns:</p> Type Description <code>int</code> <p>The edit distance between the current graph and the true graph.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.current_optimal_edit_path","title":"<code>current_optimal_edit_path: list[tuple]</code>  <code>property</code>","text":"<p>Returns the optimal edit path between the current graph and the true graph.</p> <p>Returns:</p> Type Description <code>list[tuple]</code> <p>The optimal edit path between the current graph and the true graph.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.invocations","title":"<code>invocations: int</code>  <code>property</code>","text":"<p>Returns the number of invocations of the ECCS system so far.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of invocations of the ECCS system.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.ate_trajectory","title":"<code>ate_trajectory: list[float]</code>  <code>property</code>","text":"<p>Returns the trajectory of the ATE over the invocations.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>The trajectory of the ATE over the invocations.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.ate_diff_trajectory","title":"<code>ate_diff_trajectory: list[float]</code>  <code>property</code>","text":"<p>Returns the trajectory of the ATE difference over the invocations.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>The trajectory of the ATE difference over the invocations.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.edit_distance_trajectory","title":"<code>edit_distance_trajectory: list[int]</code>  <code>property</code>","text":"<p>Returns the trajectory of the graph edit distance over the invocations.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The trajectory of the graph edit distance over the invocations.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.invocation_duration_trajectory","title":"<code>invocation_duration_trajectory: list[float]</code>  <code>property</code>","text":"<p>Returns the trajectory of the invocation durations over the invocations.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>The trajectory of the invocation durations over the invocations.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.fresh_edits_trajectory","title":"<code>fresh_edits_trajectory: list[int]</code>  <code>property</code>","text":"<p>Returns the trajectory of the number of fresh edits per invocation over the invocations. Edits are fresh when the underlying algorithm was actually invoked to produce them (as opposed to serving them from a cache).</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>The trajectory of the number of fresh edits per invocation over the invocations.</p>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.__init__","title":"<code>__init__(data, true_graph, test_graph, treatment, outcome, fixed=None, banned=None)</code>","text":"<p>Initializes the ECCSUser object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | DataFrame</code> <p>The dataset or the path to it.</p> required <code>true_graph</code> <code>str | DiGraph</code> <p>The ground truth causal graph or the path to it.</p> required <code>test_graph</code> <code>str | DiGraph</code> <p>The starting graph available to the user or the path to it.</p> required <code>treatment</code> <code>str</code> <p>The name of the treatment variable.</p> required <code>outcome</code> <code>str</code> <p>The name of the outcome variable.</p> required <code>fixed</code> <code>Optional[list[Edge]]</code> <p>An optional list of fixed edges at the start.</p> <code>None</code> <code>banned</code> <code>Optional[list[Edge]]</code> <p>An optional list of banned edges at the start.</p> <code>None</code> Source code in <code>src/evaluation/user.py</code> <pre><code>def __init__(\n    self,\n    data: str | pd.DataFrame,\n    true_graph: str | nx.DiGraph,\n    test_graph: str | nx.DiGraph,\n    treatment: str,\n    outcome: str,\n    fixed: Optional[list[Edge]] = None,\n    banned: Optional[list[Edge]] = None,\n) -&gt; None:\n    \"\"\"\n    Initializes the ECCSUser object.\n\n    Parameters:\n        data: The dataset or the path to it.\n        true_graph: The ground truth causal graph or the path to it.\n        test_graph: The starting graph available to the user or the path to it.\n        treatment: The name of the treatment variable.\n        outcome: The name of the outcome variable.\n        fixed: An optional list of fixed edges at the start.\n        banned: An optional list of banned edges at the start.\n    \"\"\"\n\n    if isinstance(data, str):\n        self._data = pd.read_csv(data)\n    else:\n        self._data = data\n\n    if isinstance(true_graph, str):\n        self._true_graph = nx.DiGraph(nx.nx_pydot.read_dot(true_graph))\n    else:\n        self._true_graph = true_graph\n\n    if isinstance(test_graph, str):\n        self._test_graph = nx.DiGraph(nx.nx_pydot.read_dot(test_graph))\n    else:\n        self._test_graph = test_graph\n\n    self._treatment = treatment\n    self._outcome = outcome\n\n    self._eccs = ECCS(data, test_graph)\n    self._eccs.set_treatment(treatment)\n    self._eccs.set_outcome(outcome)\n    self._true_ate = None\n    self._current_ate = None\n\n    # This is the index of steps where algorithms that might suggest multiple\n    # edges in one invocation got invoked, for plotting and data analysis\n    # purposes\n    self._eccs_algorithm_invocation_iters = []\n\n    self._invocations = 0\n    self._ate_trajectory = [self.current_ate]\n    self._edit_disance_trajectory = [self.current_graph_edit_distance]\n    self._invocation_duration_trajectory = []\n    self._fresh_edits_trajectory = []\n\n    if fixed:\n        for edge in fixed:\n            if self._eccs.get_edge_state(*edge) == EdgeState.PRESENT:\n                self._eccs.fix_edge(*edge)\n            else:\n                print(\n                    f\"Warning: Fixed edge {edge} is not present in the graph. It has state {EdgeState(state)}. Skipping.\"\n                )\n\n    if banned:\n        for edge in banned:\n            state = self._eccs.get_edge_state(*edge)\n            if state == EdgeState.ABSENT:\n                self._eccs.ban_edge(*edge)\n            elif (\n                state != EdgeState.BANNED\n            ):  # May be already banned because we fixed its reverse.\n                print(\n                    f\"Warning: Banned edge {edge} is not absent/banned from the graph. It has state {EdgeState(state)}. Skipping.\"\n                )\n\n    print(\"Initialized ECCS user!\")\n    print(f\"True ATE: {self.true_ate}\")\n    print(f\"Initial ATE: {self.current_ate}\")\n    print(f\"Initial ATE difference: {self.current_ate_diff}\")\n    print(f\"Initial edit distance: {self.current_graph_edit_distance}\")\n    print(f\"An optimal edit path: {self.current_optimal_edit_path}\")\n</code></pre>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.invoke_eccs","title":"<code>invoke_eccs(method=None, budget=None, max_judgments=None)</code>","text":"<p>Invokes the ECCS system and updates the fixed and banned nodes accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The method to use for edge suggestions.</p> <code>None</code> <code>budget</code> <code>int</code> <p>The budget for the invocation. Not all methods use this.</p> <code>None</code> <code>max_judgments</code> <code>int</code> <p>The maximum number of edits to produce a judgment for. If None, the system will produce a judgment for all suggested edits provided by a single invocation of the ECCS system.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>A tuple containing whether any edits were suggested and how many fresh edits were produced</p> <code>int</code> <p>during this invocation.</p> Source code in <code>src/evaluation/user.py</code> <pre><code>def invoke_eccs(\n    self, method: str = None, budget: int = None, max_judgments: int = None\n) -&gt; tuple[bool, int]:\n    \"\"\"\n    Invokes the ECCS system and updates the fixed and banned nodes accordingly.\n\n    Parameters:\n        method: The method to use for edge suggestions.\n        budget: The budget for the invocation. Not all methods use this.\n        max_judgments: The maximum number of edits to produce a judgment for. If None,\n            the system will produce a judgment for all suggested edits provided by a single\n            invocation of the ECCS system.\n\n    Returns:\n        A tuple containing whether any edits were suggested and how many fresh edits were produced\n        during this invocation.\n    \"\"\"\n\n    if (method is None) or (method not in self._eccs.EDGE_SUGGESTION_METHODS):\n        method = self._eccs.EDGE_SUGGESTION_METHODS[0]\n\n    # Get suggested modifications and selectively apply them\n    start = datetime.now()\n    edits, ate, num_fresh_edits = self._eccs.suggest(\n        method, budget, max_results=max_judgments\n    )\n    end = datetime.now()\n    self._invocation_duration_trajectory.append((end - start).total_seconds())\n    self._fresh_edits_trajectory.append(num_fresh_edits)\n    print(\n        f\"In iteration {self._invocations + 1} ECCS suggested: {edits} in {self._invocation_duration_trajectory[-1]} seconds.\"\n    )\n    if len(edits) == 0:\n        return (False, 0)\n    for src, dst, _ in edits:\n        fadd = frem = ffix = fban = False\n        radd = rrem = rfix = rban = False\n\n        # The user produces the right judgement for the pair of (src, dst) regardless of the suggested edit type.\n        if (src, dst) in self._true_graph.edges():\n            fadd = self._eccs.add_edge(src, dst)\n            ffix = self._eccs.fix_edge(src, dst)\n            rrem = self._eccs.remove_edge(dst, src, remove_isolates=False)\n            rban = self._eccs.ban_edge(dst, src)\n        elif (dst, src) in self._true_graph.edges():\n            frem = self._eccs.remove_edge(src, dst, remove_isolates=False)\n            fban = self._eccs.ban_edge(src, dst)\n            radd = self._eccs.add_edge(dst, src)\n            rfix = self._eccs.fix_edge(dst, src)\n        else:\n            frem = self._eccs.remove_edge(src, dst, remove_isolates=False)\n            fban = self._eccs.ban_edge(src, dst)\n            rrem = self._eccs.remove_edge(dst, src, remove_isolates=False)\n            rban = self._eccs.ban_edge(dst, src)\n\n        self._current_ate = None\n\n        print(\n            f\"\\tUser judgement for edge {src} -&gt; {dst}: \"\n            + (\"Add \" if fadd else \"\")\n            + (\"Remove \" if frem else \"\")\n            + (\"Fix \" if ffix else \"\")\n            + (\"Ban \" if fban else \"\")\n        )\n        print(\n            f\"\\tUser judgement for edge {dst} -&gt; {src}: \"\n            + (\"Add \" if radd else \"\")\n            + (\"Remove \" if rrem else \"\")\n            + (\"Fix \" if rfix else \"\")\n            + (\"Ban \" if rban else \"\")\n        )\n\n    # Update bookkeeping\n    self._invocations += 1\n    self._ate_trajectory.append(self.current_ate)\n    self._edit_disance_trajectory.append(self.current_graph_edit_distance)\n\n    print(f\"\\tUpdated ATE: {self.current_ate} (from {self.ate_trajectory[-2]})\")\n    print(\n        f\"\\tUpdated ATE difference: {self.current_ate_diff} (from {self.ate_diff_trajectory[-2]})\"\n    )\n    print(\n        f\"\\tUpdated edit distance: {self.current_graph_edit_distance} (from {self.edit_distance_trajectory[-2]})\"\n    )\n    return (True, num_fresh_edits)\n</code></pre>"},{"location":"reference/evaluation/user/#evaluation.user.ECCSUser.run","title":"<code>run(steps, method=None, budget=None)</code>","text":"<p>Simulate the user for <code>steps</code> steps. In each step, the user invokes the ECCS system and updates the fixed and banned edges accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>int</code> <p>The number of steps that the user executes</p> required <code>method</code> <code>str</code> <p>The method to use for edge suggestions.</p> <code>None</code> <code>budget</code> <code>int</code> <p>The budget for each invocation. Not all methods use this.</p> <code>None</code> Source code in <code>src/evaluation/user.py</code> <pre><code>def run(self, steps: int, method: str = None, budget: int = None) -&gt; None:\n    \"\"\"\n    Simulate the user for `steps` steps. In each step, the user invokes the ECCS\n    system and updates the fixed and banned edges accordingly.\n\n    Parameters:\n        steps: The number of steps that the user executes\n        method: The method to use for edge suggestions.\n        budget: The budget for each invocation. Not all methods use this.\n    \"\"\"\n\n    for i in range(steps):\n        print(f\"Running iteration {i + 1}\")\n        suggested_edits, num_fresh_edits = self.invoke_eccs(\n            method, budget, max_judgments=1\n        )\n        if num_fresh_edits &gt; 0:\n            self._eccs_algorithm_invocation_iters.append(i)\n        if not suggested_edits:\n            print(\n                \"ECCS suggested no changes. Stopping. \",\n                \"Total fresh edits produced over time: \",\n                sum(self._fresh_edits_trajectory),\n                \"Total algorithm invocations: \",\n                len(self._eccs_algorithm_invocation_iters),\n                \"Final edit distance: \",\n                self.current_graph_edit_distance,\n                \"Final ATE: \",\n                self.current_ate,\n                \"Final ATE difference: \",\n                self.current_ate_diff,\n            )\n            break\n    print(\n        \"The specific ECCS Algorithm was invoked in the following steps: \",\n        self._eccs_algorithm_invocation_iters,\n    )\n</code></pre>"},{"location":"reference/generators/","title":"Index","text":""},{"location":"reference/generators/random_dag_generator/","title":"RandomDAGGenerator","text":""},{"location":"reference/generators/random_dag_generator/#generators.random_dag_generator.RandomDAGGenerator","title":"<code>RandomDAGGenerator</code>","text":"<p>A class for the creation of random DAGs, with a potential causal interpretation.</p> Source code in <code>src/generators/random_dag_generator.py</code> <pre><code>class RandomDAGGenerator:\n    \"\"\"\n    A class for the creation of random DAGs, with a potential causal interpretation.\n    \"\"\"\n\n    DEFAULT_NUM_NODES = 10\n    DEFAULT_EDGE_PROB = 0.25\n    DEFAULT_EDGE_WEIGHT_RANGE = (-10, 10)\n    DEFAULT_EDGE_NOISE_SD_RANGE = (-2, 2)\n\n    @classmethod\n    def generate(\n        cls,\n        num_nodes: int = DEFAULT_NUM_NODES,\n        edge_prob: float = DEFAULT_EDGE_PROB,\n        edge_weight_range: tuple[float, float] = DEFAULT_EDGE_WEIGHT_RANGE,\n        edge_noise_sd_range: tuple[float, float] = DEFAULT_EDGE_NOISE_SD_RANGE,\n        out_path: str = None,\n    ) -&gt; dict[str, object]:\n        \"\"\"\n        Generates a random DAG pased on the provided parameters.\n\n        Parameters:\n            num_nodes: The number of nodes in the DAG.\n            edge_prob: The probability of an edge existing between any two nodes.\n            edge_weight_range: The range of edge weights.\n            edge_noise_sd_range: The range of edge noise standard deviations.\n            out_path: The path to write the DAG to. If None, the DAG is not written out.\n\n        Returns:\n            A dictionary with the following elements:\n            - name: The name of the generated DAG.\n            - graph: The generated DAG.\n            - edge_matrix: The edge weights of the generated DAG.\n            - noise_matrix: The noise standard deviations of the generated DAG.\n        \"\"\"\n\n        # Create a random DAG. Order nodes and only allow \"forward\" edges to ensure DAG.\n        G = nx.DiGraph()\n        for i in range(num_nodes):\n            G.add_node(f\"v{i}\", var_name=f\"v{i}\")\n\n        edge_matrix = np.array(\n            [\n                [\n                    (\n                        0\n                        if i &gt;= j\n                        else (\n                            random.uniform(*edge_weight_range)\n                            if random.random() &lt; edge_prob\n                            else 0\n                        )\n                    )\n                    for j in range(num_nodes)\n                ]\n                for i in range(num_nodes)\n            ]\n        )\n\n        noise_matrix = np.array(\n            [\n                [\n                    (\n                        0\n                        if edge_matrix[i][j] == 0\n                        else random.uniform(*edge_noise_sd_range)\n                    )\n                    for j in range(num_nodes)\n                ]\n                for i in range(num_nodes)\n            ]\n        )\n\n        for i in range(num_nodes):\n            for j in range(i, num_nodes):\n                if edge_matrix[i, j] != 0:\n                    G.add_edge(\n                        f\"v{i}\",\n                        f\"v{j}\",\n                        weight=edge_matrix[i, j],\n                        noise_sd=noise_matrix[i, j],\n                    )\n\n        # Write out optionally\n\n        # hash the current timestamp to generate a dataset name\n        dag_name = f\"dag_{hashlib.md5(str(datetime.now()).encode()).hexdigest()[:8]}\"\n        if out_path:\n            # Generation parameters\n            generation_params = {\n                \"num_nodes\": num_nodes,\n                \"edge_prob\": edge_prob,\n                \"edge_weight_range\": edge_weight_range,\n                \"edge_noise_sd_range\": edge_noise_sd_range,\n            }\n            with open(os.path.join(out_path, f\"{dag_name}_parameters.json\"), \"w\") as f:\n                json.dump(generation_params, f)\n\n            # Generated Products\n            nx.nx_pydot.write_dot(G, os.path.join(out_path, f\"{dag_name}_graph.dot\"))\n            np.save(os.path.join(out_path, f\"{dag_name}_edge_matrix.npy\"), edge_matrix)\n            np.save(\n                os.path.join(out_path, f\"{dag_name}_noise_matrix.npy\"), noise_matrix\n            )\n            esm = EdgeStateMatrix([f\"v{i}\" for i in range(num_nodes)])\n            for src, dst in G.edges():\n                esm.mark_edge(src, dst, EdgeState.PRESENT)\n            GraphRenderer.save_graph(\n                G,\n                esm,\n                os.path.join(out_path, f\"{dag_name}_graph.png\"),\n            )\n\n        out_dict = {\n            \"name\": dag_name,\n            \"graph\": G,\n            \"edge_matrix\": edge_matrix,\n            \"noise_matrix\": noise_matrix,\n        }\n\n        return out_dict\n</code></pre>"},{"location":"reference/generators/random_dag_generator/#generators.random_dag_generator.RandomDAGGenerator.generate","title":"<code>generate(num_nodes=DEFAULT_NUM_NODES, edge_prob=DEFAULT_EDGE_PROB, edge_weight_range=DEFAULT_EDGE_WEIGHT_RANGE, edge_noise_sd_range=DEFAULT_EDGE_NOISE_SD_RANGE, out_path=None)</code>  <code>classmethod</code>","text":"<p>Generates a random DAG pased on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>num_nodes</code> <code>int</code> <p>The number of nodes in the DAG.</p> <code>DEFAULT_NUM_NODES</code> <code>edge_prob</code> <code>float</code> <p>The probability of an edge existing between any two nodes.</p> <code>DEFAULT_EDGE_PROB</code> <code>edge_weight_range</code> <code>tuple[float, float]</code> <p>The range of edge weights.</p> <code>DEFAULT_EDGE_WEIGHT_RANGE</code> <code>edge_noise_sd_range</code> <code>tuple[float, float]</code> <p>The range of edge noise standard deviations.</p> <code>DEFAULT_EDGE_NOISE_SD_RANGE</code> <code>out_path</code> <code>str</code> <p>The path to write the DAG to. If None, the DAG is not written out.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>A dictionary with the following elements:</p> <code>dict[str, object]</code> <ul> <li>name: The name of the generated DAG.</li> </ul> <code>dict[str, object]</code> <ul> <li>graph: The generated DAG.</li> </ul> <code>dict[str, object]</code> <ul> <li>edge_matrix: The edge weights of the generated DAG.</li> </ul> <code>dict[str, object]</code> <ul> <li>noise_matrix: The noise standard deviations of the generated DAG.</li> </ul> Source code in <code>src/generators/random_dag_generator.py</code> <pre><code>@classmethod\ndef generate(\n    cls,\n    num_nodes: int = DEFAULT_NUM_NODES,\n    edge_prob: float = DEFAULT_EDGE_PROB,\n    edge_weight_range: tuple[float, float] = DEFAULT_EDGE_WEIGHT_RANGE,\n    edge_noise_sd_range: tuple[float, float] = DEFAULT_EDGE_NOISE_SD_RANGE,\n    out_path: str = None,\n) -&gt; dict[str, object]:\n    \"\"\"\n    Generates a random DAG pased on the provided parameters.\n\n    Parameters:\n        num_nodes: The number of nodes in the DAG.\n        edge_prob: The probability of an edge existing between any two nodes.\n        edge_weight_range: The range of edge weights.\n        edge_noise_sd_range: The range of edge noise standard deviations.\n        out_path: The path to write the DAG to. If None, the DAG is not written out.\n\n    Returns:\n        A dictionary with the following elements:\n        - name: The name of the generated DAG.\n        - graph: The generated DAG.\n        - edge_matrix: The edge weights of the generated DAG.\n        - noise_matrix: The noise standard deviations of the generated DAG.\n    \"\"\"\n\n    # Create a random DAG. Order nodes and only allow \"forward\" edges to ensure DAG.\n    G = nx.DiGraph()\n    for i in range(num_nodes):\n        G.add_node(f\"v{i}\", var_name=f\"v{i}\")\n\n    edge_matrix = np.array(\n        [\n            [\n                (\n                    0\n                    if i &gt;= j\n                    else (\n                        random.uniform(*edge_weight_range)\n                        if random.random() &lt; edge_prob\n                        else 0\n                    )\n                )\n                for j in range(num_nodes)\n            ]\n            for i in range(num_nodes)\n        ]\n    )\n\n    noise_matrix = np.array(\n        [\n            [\n                (\n                    0\n                    if edge_matrix[i][j] == 0\n                    else random.uniform(*edge_noise_sd_range)\n                )\n                for j in range(num_nodes)\n            ]\n            for i in range(num_nodes)\n        ]\n    )\n\n    for i in range(num_nodes):\n        for j in range(i, num_nodes):\n            if edge_matrix[i, j] != 0:\n                G.add_edge(\n                    f\"v{i}\",\n                    f\"v{j}\",\n                    weight=edge_matrix[i, j],\n                    noise_sd=noise_matrix[i, j],\n                )\n\n    # Write out optionally\n\n    # hash the current timestamp to generate a dataset name\n    dag_name = f\"dag_{hashlib.md5(str(datetime.now()).encode()).hexdigest()[:8]}\"\n    if out_path:\n        # Generation parameters\n        generation_params = {\n            \"num_nodes\": num_nodes,\n            \"edge_prob\": edge_prob,\n            \"edge_weight_range\": edge_weight_range,\n            \"edge_noise_sd_range\": edge_noise_sd_range,\n        }\n        with open(os.path.join(out_path, f\"{dag_name}_parameters.json\"), \"w\") as f:\n            json.dump(generation_params, f)\n\n        # Generated Products\n        nx.nx_pydot.write_dot(G, os.path.join(out_path, f\"{dag_name}_graph.dot\"))\n        np.save(os.path.join(out_path, f\"{dag_name}_edge_matrix.npy\"), edge_matrix)\n        np.save(\n            os.path.join(out_path, f\"{dag_name}_noise_matrix.npy\"), noise_matrix\n        )\n        esm = EdgeStateMatrix([f\"v{i}\" for i in range(num_nodes)])\n        for src, dst in G.edges():\n            esm.mark_edge(src, dst, EdgeState.PRESENT)\n        GraphRenderer.save_graph(\n            G,\n            esm,\n            os.path.join(out_path, f\"{dag_name}_graph.png\"),\n        )\n\n    out_dict = {\n        \"name\": dag_name,\n        \"graph\": G,\n        \"edge_matrix\": edge_matrix,\n        \"noise_matrix\": noise_matrix,\n    }\n\n    return out_dict\n</code></pre>"},{"location":"reference/generators/random_dataset_generator/","title":"RandomDatasetGenerator","text":""},{"location":"reference/generators/random_dataset_generator/#generators.random_dataset_generator.RandomDatasetGenerator","title":"<code>RandomDatasetGenerator</code>","text":"<p>A class for creating a random dataset based on an input causal DAG.</p> Source code in <code>src/generators/random_dataset_generator.py</code> <pre><code>class RandomDatasetGenerator:\n    \"\"\"\n    A class for creating a random dataset based on an input causal DAG.\n    \"\"\"\n\n    DEFAULT_NUM_POINTS = 1000\n    DEFAULT_MIN_SOURCE_VAL = 0\n    DEFUALT_MAX_SOURCE_VAL = 10\n\n    @staticmethod\n    def generate(\n        dag_name: str,\n        edge_matrix: np.ndarray,\n        noise_matrix: np.ndarray,\n        num_points: int = DEFAULT_NUM_POINTS,\n        min_source_val: float = DEFAULT_MIN_SOURCE_VAL,\n        max_source_val: float = DEFUALT_MAX_SOURCE_VAL,\n        out_path: str = None,\n    ) -&gt; dict[str, object]:\n        \"\"\"\n        Generates a random dataset of `num_points` data points based on the given matrices about the causal DAG.\n        We assume that the nodes in the DAG are in topological order.\n\n        Parameters:\n            dag_name: The name of the DAG.\n            edge_matrix: The edge weight matrix of the causal DAG.\n            noise_matrix: The noise standard deviation matrix of the causal DAG.\n            num_points: The number of data points.\n            min_source_val: The minimum value for source variables.\n            max_source_val: The maximum value for source variables.\n            out_path: The path to write the dataset to. If None, the dataset is not written out.\n\n        Returns:\n            A dictionary with the following elements:\n            - name: The name of the generated dataset.\n            - data: The generated dataset.\n        \"\"\"\n\n        num_vars = edge_matrix.shape[0]\n\n        data = np.zeros((num_points, num_vars))\n        data[:, 0] = np.random.uniform(min_source_val, max_source_val, num_points)\n        for j in range(1, num_vars):\n            # Determine that this variable is a source if all incoming weights are zero.\n            if np.all(edge_matrix[:, j] == 0):\n                data[:, j] = np.random.uniform(\n                    min_source_val, max_source_val, num_points\n                )\n                continue\n\n            # Calculate the value of the jth variable based on the values of the previous variables (incoming edges).\n            for i in range(j):\n                data[:, j] += edge_matrix[i, j] * data[:, i] + np.random.normal(\n                    0, noise_matrix[i, j]\n                )\n\n        # Convert to dataframe\n        data_df = pd.DataFrame(data, columns=[f\"v{i}\" for i in range(num_vars)])\n\n        # Write out optionally\n        dataset_name = f\"{dag_name}_dataset_{hashlib.md5(str(datetime.now()).encode()).hexdigest()[:8]}\"\n        if out_path:\n            # Generation parameters\n            generation_params = {\n                \"num_points\": num_points,\n                \"min_source_val\": min_source_val,\n                \"max_source_val\": max_source_val,\n            }\n            with open(\n                os.path.join(out_path, f\"{dataset_name}_parameters.json\"), \"w\"\n            ) as f:\n                json.dump(generation_params, f)\n\n            data_df.to_csv(os.path.join(out_path, f\"{dataset_name}.csv\"), index=False)\n\n        return {\"name\": dataset_name, \"data\": data_df}\n</code></pre>"},{"location":"reference/generators/random_dataset_generator/#generators.random_dataset_generator.RandomDatasetGenerator.generate","title":"<code>generate(dag_name, edge_matrix, noise_matrix, num_points=DEFAULT_NUM_POINTS, min_source_val=DEFAULT_MIN_SOURCE_VAL, max_source_val=DEFUALT_MAX_SOURCE_VAL, out_path=None)</code>  <code>staticmethod</code>","text":"<p>Generates a random dataset of <code>num_points</code> data points based on the given matrices about the causal DAG. We assume that the nodes in the DAG are in topological order.</p> <p>Parameters:</p> Name Type Description Default <code>dag_name</code> <code>str</code> <p>The name of the DAG.</p> required <code>edge_matrix</code> <code>ndarray</code> <p>The edge weight matrix of the causal DAG.</p> required <code>noise_matrix</code> <code>ndarray</code> <p>The noise standard deviation matrix of the causal DAG.</p> required <code>num_points</code> <code>int</code> <p>The number of data points.</p> <code>DEFAULT_NUM_POINTS</code> <code>min_source_val</code> <code>float</code> <p>The minimum value for source variables.</p> <code>DEFAULT_MIN_SOURCE_VAL</code> <code>max_source_val</code> <code>float</code> <p>The maximum value for source variables.</p> <code>DEFUALT_MAX_SOURCE_VAL</code> <code>out_path</code> <code>str</code> <p>The path to write the dataset to. If None, the dataset is not written out.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>A dictionary with the following elements:</p> <code>dict[str, object]</code> <ul> <li>name: The name of the generated dataset.</li> </ul> <code>dict[str, object]</code> <ul> <li>data: The generated dataset.</li> </ul> Source code in <code>src/generators/random_dataset_generator.py</code> <pre><code>@staticmethod\ndef generate(\n    dag_name: str,\n    edge_matrix: np.ndarray,\n    noise_matrix: np.ndarray,\n    num_points: int = DEFAULT_NUM_POINTS,\n    min_source_val: float = DEFAULT_MIN_SOURCE_VAL,\n    max_source_val: float = DEFUALT_MAX_SOURCE_VAL,\n    out_path: str = None,\n) -&gt; dict[str, object]:\n    \"\"\"\n    Generates a random dataset of `num_points` data points based on the given matrices about the causal DAG.\n    We assume that the nodes in the DAG are in topological order.\n\n    Parameters:\n        dag_name: The name of the DAG.\n        edge_matrix: The edge weight matrix of the causal DAG.\n        noise_matrix: The noise standard deviation matrix of the causal DAG.\n        num_points: The number of data points.\n        min_source_val: The minimum value for source variables.\n        max_source_val: The maximum value for source variables.\n        out_path: The path to write the dataset to. If None, the dataset is not written out.\n\n    Returns:\n        A dictionary with the following elements:\n        - name: The name of the generated dataset.\n        - data: The generated dataset.\n    \"\"\"\n\n    num_vars = edge_matrix.shape[0]\n\n    data = np.zeros((num_points, num_vars))\n    data[:, 0] = np.random.uniform(min_source_val, max_source_val, num_points)\n    for j in range(1, num_vars):\n        # Determine that this variable is a source if all incoming weights are zero.\n        if np.all(edge_matrix[:, j] == 0):\n            data[:, j] = np.random.uniform(\n                min_source_val, max_source_val, num_points\n            )\n            continue\n\n        # Calculate the value of the jth variable based on the values of the previous variables (incoming edges).\n        for i in range(j):\n            data[:, j] += edge_matrix[i, j] * data[:, i] + np.random.normal(\n                0, noise_matrix[i, j]\n            )\n\n    # Convert to dataframe\n    data_df = pd.DataFrame(data, columns=[f\"v{i}\" for i in range(num_vars)])\n\n    # Write out optionally\n    dataset_name = f\"{dag_name}_dataset_{hashlib.md5(str(datetime.now()).encode()).hexdigest()[:8]}\"\n    if out_path:\n        # Generation parameters\n        generation_params = {\n            \"num_points\": num_points,\n            \"min_source_val\": min_source_val,\n            \"max_source_val\": max_source_val,\n        }\n        with open(\n            os.path.join(out_path, f\"{dataset_name}_parameters.json\"), \"w\"\n        ) as f:\n            json.dump(generation_params, f)\n\n        data_df.to_csv(os.path.join(out_path, f\"{dataset_name}.csv\"), index=False)\n\n    return {\"name\": dataset_name, \"data\": data_df}\n</code></pre>"}]}